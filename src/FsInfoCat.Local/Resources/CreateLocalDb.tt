<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Xml.ReaderWriter"#>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Collections.ObjectModel" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ include file="../../FsInfoCat/core.ttinclude" #>
<#@ output extension=".sql" #>
-- Deleting tables

<#
foreach (XAttribute attribute in EntityDefinitionsDocument.Root.Elements("Local").Elements("Entity").Attributes("TableName").Reverse())
{
#>
DROP TABLE IF EXISTS "<#=attribute.Value#>";
<#
}
#>

-- Creating tables

<#
foreach (XAttribute tableAttribute in EntityDefinitionsDocument.Root.Elements("Local").Elements("Entity").Attributes("TableName"))
{
    XElement entityElement = tableAttribute.Parent;
    GenerateCreateTableSql(tableAttribute.Value, tableAttribute.Parent);
}
#>
<#+

void GenerateCreateTableSql(string tableName, XElement entityElement)
{
    string entityName = entityElement.Attribute(XNAME_Name)?.Value;
    Write("CREATE TABLE IF NOT EXISTS ");
    Write(tableName);
    WriteLine(" (");
    PushIndent("    ");
    Collection<(string Name, LinkedList<XElement> Sources)> collection = new();
    GetAllProperties(entityElement, collection);
    (string Name, LinkedList<XElement> Sources) firstCol = new(GenerateTableColumnSql(tableName, entityName, collection[0].Name, collection[0].Sources), collection[0].Sources);
    (string Name, LinkedList<XElement> Sources)[] columns = new (string Name, LinkedList<XElement> Sources)[] { firstCol }
        .Concat(collection.Skip(1).Select<(string Name, LinkedList<XElement> Sources), (string Name, LinkedList<XElement> Sources)>(t =>
        {
            WriteLine(",");
            return new(GenerateTableColumnSql(tableName, entityName, t.Name, t.Sources), t.Sources);
        }).Where(t => t.Name is not null)).ToArray();
    string[] keyColumns = columns.Where(c => c.Sources.Where(e => e.Attribute(XNAME_IsPrimaryKey)?.Value == "true" && (e.Name == XNAME_UniqueIdentifier || e.Name == XNAME_UniqueIdentifier)))
        .Select(c => $"\"{c.Name}\"").ToArray();
    Collection<string> constraints = new();
    foreach (XElement element in new XElement[] { entityElement }.Concat(GetAllBaseEntities(entityElement)))
    {
        if (element.Name == XNAME_EitherOrConstraint)
        {
            string p1 = element.Elements(XNAME_Property).Take(1).Select(p =>
            {
                string disallowEmptyIfNotNull = p.Attribute(XNAME_DisallowEmptyIfNotNull)?.Value;
                if (string.IsNullOrWhiteSpace(disallowEmptyIfNotNull))
                    return $"\"{p.Attribute(XNAME_Name)?.Value}\" IS NULL";
                return $"(\"{p.Attribute(XNAME_Name)?.Value}\" IS NULL OR length(trim(\"{disallowEmptyIfNotNull}\")>0)";
            }).First();
            string p2 = element.Elements(XNAME_Property).Skip(1).Take(1).Select(p =>
            {
                string disallowEmptyIfNotNull = p.Attribute(XNAME_DisallowEmptyIfNotNull)?.Value;
                if (string.IsNullOrWhiteSpace(disallowEmptyIfNotNull))
                    return $"\"{p.Attribute(XNAME_Name)?.Value}\" IS NULL";
                return $"(\"{p.Attribute(XNAME_Name)?.Value}\" IS NOT NULL AND length(trim(\"{disallowEmptyIfNotNull}\")>0)";
            }).First();
            string value = $"{p2} OR {p1}";
            if (constraints.Contains(value))
                continue;
            value = $"{p1} OR {p2}";
            if (!constraints.Contains(value))
                constraints.Add(value);
        }
        else if (element.Name == XNAME_IsNullSameConstraint)
        {
            string[] values = element.Elements(XNAME_Property).Attributes(XNAME_Name).Select(a => a.Value).ToArray();
            string value = $"\"{values[1]}\" IS NULL OR \"{values[0]}\" IS NOT NULL";
            if (constraints.Contains(value))
                continue;
            value = $"\"{values[0]}\" IS NULL OR \"{values[1]}\" IS NOT NULL";
            if (!constraints.Contains(value))
                constraints.Add(value);
        }
        else if (element.Name == XNAME_FieldComparisonConstraint)
        {
            string leftProperty = element.Attribute(XNAME_LeftProperty)?.Value;
            string rightProperty = element.Attribute(XNAME_RightProperty)?.Value;
            string value;
            switch (element.Attribute(XNAME_Operator)?.Value ?? "")
            {
                case "LessThan":
                    value = $"\"{rightProperty}\">=\"{leftProperty}\"";
                    if (constraints.Contains(value))
                        continue;
                    value = $"\"{leftProperty}\"<\"{rightProperty}\"";
                    break;
                case "NotGreaterThan":
                    value = $"\"{rightProperty}\">\"{leftProperty}\"";
                    if (constraints.Contains(value))
                        continue;
                    value = $"\"{leftProperty}\"<=\"{rightProperty}\"";
                    break;
                case "NotEqualTo":
                    value = $"\"{rightProperty}\"<>\"{leftProperty}\"";
                    if (constraints.Contains(value))
                        continue;
                    value = $"\"{leftProperty}\"<>\"{rightProperty}\"";
                    break;
                case "NotLessThan":
                    value = $"\"{rightProperty}\"<\"{leftProperty}\"";
                    if (constraints.Contains(value))
                        continue;
                    value = $"\"{leftProperty}\">=\"{rightProperty}\"";
                    break;
                case "GreaterThan":
                    value = $"\"{rightProperty}\"<=\"{leftProperty}\"";
                    if (constraints.Contains(value))
                        continue;
                    value = $"\"{leftProperty}\">\"{rightProperty}\"";
                    break;
                default:
                    value = $"\"{rightProperty}\"=\"{leftProperty}\"";
                    if (constraints.Contains(value))
                        continue;
                    value = $"\"{leftProperty}\"=\"{rightProperty}\"";
                    break;
            }
            if (!constraints.Contains(value))
                constraints.Add(value);
        }
    }
    // TODO: Need to change from appending comma/newline in case there are no constraints or key columns
    if (keyColumns.Length == 1)
    {
        WriteLine(",");
        Write("CONSTRAINT \"PK_");
        Write(tableName);
        Write("\" PRIMARY KEY(\"");
        Write(keyColumns[0]);
        if (constraints.Count > 0)
            Write("\")");
        else
            WriteLine("\")");
    }
    else if (keyColumns.Length > 1)
    {
        WriteLine(",");
        Write("CONSTRAINT \"PK_");
        Write(tableName);
        Write("\" PRIMARY KEY(\"");
        Write(keyColumns[0]);
        foreach (string c in keyColumns.Skip(1))
        {
            Write(", ");
            Write(c);
        }
        if (constraints.Count > 0)
            Write("\")");
        else
            WriteLine("\")");
    }
    if (constraints.Count == 1)
    {
        WriteLine(",");
        Write("CHECK(");
        Write(constraints[0]);
        WriteLine(")");
    }
    else if (constraints.Count > 1)
    {
        WriteLine(",");
        Write("CHECK((");
        Write(constraints[0]);
        foreach (string c in constraints.Skip(1))
        {
            Write(") AND (");
            Write(c);
        }
        WriteLine("))");
    }
    else if (keyColumns.Length == 0)
        WriteLine("");
    PopIndent();
    WriteLine(");");
    foreach ((string Name, LinkedList<XElement> Sources) tuple in columns)
        GenerateTableIndexSql(tableName, entityName, tuple.Name, tuple.Sources);
}

string PropertyElementToSqlType(XElement propertyElement, out string typeName, out bool isNumeric)
{
    if (propertyElement is null || propertyElement.Name.NamespaceName.Length > 0)
    {
        isNumeric = false;
        typeName = "BLOB";
        return typeName;
    }
    switch (propertyElement.Name.LocalName)
    {
        case NAME_Enum:
            return PropertyElementToSqlType(FindLocalEnumByName(propertyElement.Attribute(XNAME_Type)?.Value), out typeName, out isNumeric);
        case NAME_UniqueIdentifier:
        case NAME_RelatedEntity:
            isNumeric = false;
            typeName = "UNIQUEIDENTIFIER";
            return typeName;
        case NAME_NVarChar:
            isNumeric = false;
            typeName = "NVARCHAR";
            return $"{typeName}({propertyElement.Attribute(XNAME_MaxLength)?.Value})";
        case NAME_VolumeIdentifier:
            isNumeric = false;
            typeName = "NVARCHAR";
            return "NVARCHAR(1024)";
        case NAME_MultiStringValue:
        case NAME_Text:
            isNumeric = false;
            typeName = "TEXT";
            return typeName;
        case NAME_DateTime:
            isNumeric = false;
            typeName = "DATETIME";
            return typeName;
        case NAME_TimeSpan:
            isNumeric = false;
            typeName = "TIME";
            return typeName;
        case NAME_Bit:
            isNumeric = false;
            typeName = "BIT";
            return typeName;
        case NAME_ByteValues:
            isNumeric = false;
            typeName = "VARBINARY";
            return $"{typeName}({propertyElement.Attribute(XNAME_MaxLength)?.Value})";
        case NAME_MD5Hash:
            isNumeric = false;
            typeName = "BINARY";
            return "BINARY(16)";
        case NAME_DriveType:
            isNumeric = false;
            typeName = "UNSIGNED TINYINT";
            return typeName;
        case NAME_Byte:
            isNumeric = true;
            typeName = "UNSIGNED TINYINT";
            return typeName;
        case NAME_SByte:
            isNumeric = true;
            typeName = "TINYINT";
            return typeName;
        case NAME_Short:
            isNumeric = true;
            typeName = "SMALLINT";
            return typeName;
        case NAME_UShort:
            isNumeric = true;
            typeName = "UNSIGNED SMALLINT";
            return typeName;
        case NAME_Int:
            isNumeric = true;
            typeName = "INT";
            return typeName;
        case NAME_UInt:
            isNumeric = true;
            typeName = "UNSIGNED INT";
            return typeName;
        case NAME_Long:
            isNumeric = true;
            typeName = "BIGINT";
            return typeName;
        case NAME_ULong:
            isNumeric = true;
            typeName = "UNSIGNED BIGINT";
            return typeName;
        case NAME_Float:
        case NAME_Double:
            isNumeric = true;
            typeName = "REAL";
            return typeName;
        case NAME_Decimal:
            isNumeric = true;
            typeName = "NUMERIC";
            return typeName;
        default:
            isNumeric = false;
            typeName = null;
            return typeName;
    }
}

string GenerateTableColumnSql(string tableName, string entityName, string propertyName, LinkedList<XElement> sources, out string comment)
{
    XElement baseProperty = sources.Last.Value;
    if (baseProperty.Name == XNAME_CollectionNavigation)
    {
        comment = null;
        return null;
    }
    XElement implProperty = sources.First.Value;
    string propertyTypeName = baseProperty.Name.LocalName;
    string colName = implProperty.Attribute(XNAME_ColName)?.Value ?? propertyName;
    bool isIndexed = sources.Attributes(XNAME_IsIndexed).Any(a => a.Value == "true");
    bool defaultNull = sources.Elements(XNAME_DefaultNull).Any();
    bool allowNull = defaultNull || sources.Attributes(XNAME_AllowNull).Any(a => a.Value == "true");
    Write("\"");
    Write(colName);
    Write("\" ");
    Write(PropertyElementToSqlType(baseProperty, out string typeName, out bool isNumeric));
    if (!allowNull)
        Write(" NOT NULL");

    if (isNumeric)
    {
        string minValue = sources.Attributes(XNAME_MinValue).Select(a => a.Value.Trim()).DefaultIfEmpty("").First();
        string maxValue = sources.Attributes(XNAME_MaxValue).Select(a => a.Value.Trim()).DefaultIfEmpty("").First();
        if (minValue.Length > 0)
        {
            if (maxValue.Length > 0)
            {
                if (allowNull)
                    Write($" CHECK(\"{colName}\" IS NULL OR (\"{colName}\">={minValue} AND \"{colName}\"<={maxValue}))");
                else
                    Write($" CHECK(\"{colName}\">={minValue} AND \"{colName}\"<={maxValue})");
            }
            else if (allowNull)
                Write($" CHECK(\"{colName}\" IS NULL OR \"{colName}\">={minValue})");
            else
                Write($" CHECK(\"{colName}\">={minValue})");
        }
        else if (maxValue.Length > 0)
        {
            if (allowNull)
                Write($" CHECK(\"{colName}\" IS NULL OR \"{colName}\"<={maxValue})");
            else
                Write($" CHECK(\"{colName}\"<={maxValue})");
        }
    }
    else
    {
        int minLength;
        switch (propertyTypeName)
        {
            case NAME_NVarChar:
                minLength = sources.Attributes(XNAME_MinLength).Select(a => XmlConvert.ToInt32(a.Value.Trim())).DefaultIfEmpty(0).First();
                if (minLength > 0)
                {
                    if (sources.Attributes(XNAME_IsNormalized).Any(a => a.Value == "true"))
                    {
                        if (allowNull)
                            Write($" CHECK(\"{colName}\" IS NULL OR (length(trim(\"{colName}\") = length(\"{colName}\") AND length(\"{colName}\")>{minLength - 1}))");
                        else
                            Write($" CHECK(length(trim(\"{colName}\") = length(\"{colName}\") AND length(\"{colName}\")>{minLength - 1})");
                    }
                    else if (allowNull)
                        Write($" CHECK(\"{colName}\" IS NULL OR length(\"{colName}\")>{minLength - 1})");
                    else
                        Write($" CHECK(length(\"{colName}\")>{minLength - 1})");
                }
                else if (sources.Attributes(XNAME_IsNormalized).Any(a => a.Value == "true"))
                {
                    if (allowNull)
                        Write($" CHECK(\"{colName}\" IS NULL OR length(trim(\"{colName}\") = length(\"{colName}\"))");
                    else
                        Write($" CHECK(length(trim(\"{colName}\") = length(\"{colName}\"))");
                }
                break;
            case NAME_ByteValues:
                minLength = sources.Attributes(XNAME_MinLength).Select(a => XmlConvert.ToInt32(a.Value.Trim())).DefaultIfEmpty(0).First();
                int maxLength = sources.Attributes(XNAME_MaxLength).Select(a => XmlConvert.ToInt32(a.Value.Trim())).DefaultIfEmpty(0).First();
                if (minLength > 0)
                {
                    if (maxLength > 0)
                    {
                        if (allowNull)
                            Write($" CHECK(\"{colName}\" IS NULL OR (length(\"{colName}\")<{maxLength + 1} AND length(\"{colName}\")>{minLength - 1}))");
                        else
                            Write($" CHECK(length(\"{colName}\")<{maxLength + 1} AND length(\"{colName}\")>{minLength - 1})");
                    }
                    else if (allowNull)
                        Write($" CHECK(\"{colName}\" IS NULL OR length(\"{colName}\")>{minLength - 1})");
                    else
                        Write($" CHECK(length(\"{colName}\")>{minLength - 1})");
                }
                else if (maxLength > 0)
                {
                    if (allowNull)
                        Write($" CHECK(\"{colName}\" IS NULL OR length(\"{colName}\")<{maxLength + 1})");
                    else
                        Write($" CHECK(length(\"{colName}\")<{maxLength + 1})");
                }
                break;
            case NAME_RelatedEntity:
                XElement parentEntityElement = FindLocalEntityByName(sources.Elements(XNAME_Reference).Select(e => e.Value).First());
                Write("CONSTRAINT \"FK_");
                Write(typeName);
                Write(parentEntityElement.Attribute(XNAME_Name)?.Value);
                Write("\" REFERENCES \"");
                Write(parentEntityElement.Attribute(XNAME_TableName)?.Value);
                Write("\"(\"Id\") ON DELETE RESTRICT");
                break;
        }
    }

    if (defaultNull)
    {
        comment = null;
        Write(" DEFAULT NULL");
    }
    else
    {
        string defaultValue = sources.Elements(XNAME_Default).Select(e => e.Value).FirstOrDefault();
        if (defaultValue is null)
        {
            switch (propertyTypeName)
            {
                case NAME_DateTime:
                    if (sources.Elements(XNAME_DefaultNow).Any())
                        Write(" DEFAULT (datetime('now','localtime'))");
                    break;
                case NAME_TimeSpan:
                    if (sources.Elements(XNAME_DefaultZero).Any())
                        Write(" DEFAULT (time('00:00:00.000'))");
                    break;
                case NAME_ByteValues:
                    if (sources.Elements(XNAME_DefaultEmpty).Any())
                        Write(" DEFAULT X''");
                    break;
            }
            comment = null;
        }
        else
        {
            switch (propertyTypeName)
            {
                case NAME_Enum:
                    Write(FindLocalFieldByFullName(defaultValue.Trim())?.Value);
                    comment = defaultValue.Trim();
                    break;
                case NAME_Char:
                case NAME_NVarChar:
                case NAME_VolumeIdentifier:
                case NAME_MultiStringValue:
                case NAME_Text:
                    Write(" DEFAULT '");
                    Write($"'{defaultValue.Replace("'", "''")}'");
                    Write("'");
                    break;
                case NAME_TimeSpan:
                    Write(" DEFAULT ");
                    Write(XmlConvert.ToTimeSpan(defaultValue.Trim()).ToString(@"\'hh\:mm\:ss\.fff\'"));
                    break;
                case NAME_DateTime:
                    Write(XmlConvert.ToDateTime(defaultValue.Trim(), XmlDateTimeSerializationMode.RoundtripKind).ToLocalTime().ToString(@"'yyyy-MM-dd HH:mm:ss"));
                    break;
                case NAME_Bit:
                    Write((defaultValue == "true") ? " DEFAULT 1," : " DEFAULT 0");
                    break;
                case NAME_ByteValues:
                    Write(" DEFAULT X'");
                    Write(BitConverter.ToString(Convert.FromBase64String(defaultValue.Trim())));
                    Write("'");
                    break;
                case NAME_DriveType:
                    switch (defaultValue.Trim())
                    {
                        case "NoRootDirectory":
                            Write(" DEFAULT 1");
                            comment = "DriveType.NoRootDirectory";
                            break;
                        case "Removable":
                            Write(" DEFAULT 2");
                            comment = "DriveType.Removable";
                            break;
                        case "Fixed":
                            Write(" DEFAULT 3");
                            comment = "DriveType.Fixed";
                            break;
                        case "Network":
                            Write(" DEFAULT 4");
                            comment = "DriveType.Network";
                            break;
                        case "CDRom":
                            Write(" DEFAULT 5");
                            comment = "DriveType.CDRom";
                            break;
                        case "Ram":
                            Write(" DEFAULT 6");
                            comment = "DriveType.Ram";
                            break;
                        default:
                            Write(" DEFAULT 0");
                            comment = defaultValue.Trim();
                            break;
                    }
                    break;
                default:
                    comment = null;
                    Write(" DEFAULT ");
                    Write(defaultValue);
                    break;
            }
        }
    }
    if (sources.Attributes(XNAME_IsUnique).Any(a => a.Value == "true"))
        Write(" UNIQUE");
    switch (propertyTypeName)
    {
        case NAME_RelatedEntity:
        case NAME_UniqueIdentifier:
        case NAME_VolumeIdentifier:
            Write(" COLLATE NOCASE");
            break;
        case NAME_NVarChar:
            XAttribute attribute = sources.Attributes(XNAME_IsUnique).FirstOrDefault();
            if (attribute is not null)
            {
                Write(" COLLATE ");
                Write(attribute.Value);
            }
            break;
    }
    return colName;
}

void GenerateTableIndexSql(string tableName, string entityName, string colName, LinkedList<XElement> sources)
{
}

#>
