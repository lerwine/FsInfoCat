<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Collections.ObjectModel" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ include file="core.ttinclude" #>
<#@ output extension=".cs" #>
using FsInfoCat.Collections;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.IO;

namespace <#=DefaultNamespace#>
{<#
    GenerateEntityInterface(EntitiesDocument.Root.Elements("Entity"));
#>
}

namespace <#=DefaultNamespace#>.Local
{<#
    GenerateEntityInterface(EntitiesDocument.Root.Elements("Local").Elements("Entity"));
#>
}

namespace <#=DefaultNamespace#>.Upstream
{<#
    GenerateEntityInterface(EntitiesDocument.Root.Elements("Upstream").Elements("Entity"));
#>
}
<#+

void GenerateEntityInterface(IEnumerable<XElement> entityElements)
{
    foreach (XElement entityElement in entityElements)
    {
        WriteLine("");
        string rt = entityElement.Attributes("ResourceType").Select(a => a.Value).Where(s => !string.IsNullOrWhiteSpace(s)).DefaultIfEmpty("Properties.Resources").First();
        string extends = string.Join(", ", entityElement.Elements("Extends").Attributes("cref").Select(a => a.Value.Replace('{', '<').Replace('}', '>')));
        XElement[] allBaseEntityTypes =  GetAllBaseEntityTypes(entityElement).ToArray();
        IEnumerable<XElement> docXElements = GetByNames(entityElement, "summary", "typeparam", "remarks", "seealso");
        docXElements = docXElements.Select(e => WithoutElementNamespace(e));
        foreach (string entityDoc in ToXmlLines(docXElements))
        {
#>
    /// <#=entityDoc#>
<#+
        }
        IEnumerable<XElement> propertyElementList = entityElement.Elements("Property");
        if (propertyElementList.Any())
        {
#>
    public interface <#=entityElement.Attribute("Name").Value.Replace('{', '<').Replace('}', '>')#><#=(extends.Length > 0) ? $" : {extends}" : ""#>
    {<#+
            foreach (XElement propertyElement in propertyElementList)
            {
                WriteLine("");
                docXElements = GetByNames(propertyElement, "summary", "value", "remarks", "seealso");
                docXElements = docXElements.Select(e => WithoutElementNamespace(e));
                foreach (string entityDoc in ToXmlLines(docXElements))
                {
#>
        /// <#=entityDoc#>
<#+
                }
                string propertyName = propertyElement.Attributes("DisplayNameResource").Select(a => a.Value).FirstOrDefault();
                string typeName = propertyElement.Attributes("DescriptionResource").Select(a => a.Value).FirstOrDefault();
                if (string.IsNullOrWhiteSpace(typeName))
                {
                    if (!string.IsNullOrWhiteSpace(propertyName))
                    {
#>
        [Display(Name = nameof(Properties.Resources.<#=propertyName#>), ResourceType = typeof(<#=rt#>))]
<#+
                    }
                }
                else if (string.IsNullOrWhiteSpace(propertyName))
                {
#>
        [Display(Description = nameof(Properties.Resources.<#=typeName#>), ResourceType = typeof(<#=rt#>))]
<#+
                }
                else
                {
#>
        [Display(Name = nameof(Properties.Resources.<#=propertyName#>), Description = nameof(Properties.Resources.<#=typeName#>), ResourceType = typeof(<#=rt#>))]
<#+
                }
                propertyName = propertyElement.Attribute("Name").Value;
                typeName = propertyElement.Attribute("Type").Value.Replace('{', '<').Replace('}', '>');
                if (!propertyElement.Attributes("NotNull").Any(a => a.Value == "true"))
                    switch (typeName)
                    {
                        case "bool":
                        case "byte":
                        case "sbyte":
                        case "short":
                        case "ushort":
                        case "int":
                        case "uint":
                        case "long":
                        case "ulong":
                        case "float":
                        case "double":
                        case "decimal":
                        case "Guid":
                        case "DateTime":
                        case "DriveType":
                        case "ErrorCode":
                        case "AccessErrorCode":
                        case "FileCrawlOptions":
                        case "FileCorrelationStatus":
                        case "DirectoryCrawlOptions":
                        case "DirectoryStatus":
                        case "VolumeStatus":
                        case "VolumeIdentifier":
                        case "MD5Hash":
                            typeName = $"{typeName}?";
                            break;
                    }
                if (allBaseEntityTypes.Any(t =>  t.Elements("Property").Any(e => e.Attribute("Name")?.Value == propertyName)))
                    typeName = $"new {typeName}";
                string accessor = propertyElement.Attributes("GenericWritable").Any(a => a.Value == "true") ? "{ get; set; }" : "{ get; }";
#>
        <#=typeName#> <#=propertyName#> <#=accessor#>
<#+
            }
#>
    }
<#+
        }
        else
        {
#>
    public interface <#=entityElement.Attribute("Name").Value.Replace('{', '<').Replace('}', '>')#><#=(extends.Length > 0) ? $" : {extends}" : ""#> { }
<#+
        }
    }
}
#>
