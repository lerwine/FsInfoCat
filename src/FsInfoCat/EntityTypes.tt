<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Text.RegularExpressions" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Xml.XDocument" #>
<#@ assembly name="System.Xml.ReaderWriter"#>
<#@ assembly name="C:\Users\lerwi\Git\FsInfoCat\src\CodeGeneration\bin\Debug\net5.0\CodeGeneration.dll"#>
<#@ import namespace="CodeGeneration" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Collections.ObjectModel" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ include file="core.ttinclude" #>
<#@ output extension=".cs" #>
using FsInfoCat.Collections;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.IO;

namespace <#=DefaultNamespace#>
{
<#

XElement entityDefinitionsElement = EntityDefinitionsDocument.Root;

foreach (ValidationEventArgs e in ValidationErrors)
{
    if (e.Severity == XmlSeverityType.Warning)
        Write($"#warning XML Validation message: {e.Message}");
    else
    {
        XmlSchemaException error = e.Exception;
        if (error is null)
            WriteLine($"#error Validation error: {e.Message}");
        else
            WriteLine($"#error LineNumber {error.LineNumber}, LinePosition {error.LinePosition}: {e.Message}");
    }
}

foreach (XElement enumElement in entityDefinitionsElement.Elements().Elements(CgConstants.XNAME_EnumTypes).Elements())
{
    string typeName = enumElement.Attribute(CgConstants.XNAME_Name)?.Value;
    XName elementName = enumElement.Name;
    if (string.IsNullOrWhiteSpace(typeName))
        WriteLine($"#warning {CgConstants.XNAME_Name} attribute missing or empty for /{enumElement.Parent.Parent.Parent.Name}/{enumElement.Parent.Parent.Name}/{CgConstants.XNAME_EnumTypes}/{elementName}[{(enumElement.NodesBeforeSelf().OfType<XElement>().Count(e => e.Name == elementName) + 1)}]");
    else
    {
        string enumXPath = $"/{enumElement.Parent.Parent.Parent.Name}/{enumElement.Parent.Parent.Name}/{CgConstants.XNAME_EnumTypes}/{elementName}[@Name='{typeName}']";
        foreach (XElement fieldElement in enumElement.Elements(CgConstants.XNAME_Field))
        {
            string fieldName = fieldElement.Attribute(CgConstants.XNAME_Name)?.Value;
            if (string.IsNullOrWhiteSpace(fieldName))
                WriteLine($"#warning {CgConstants.XNAME_Name} attribute missing or empty for {enumXPath}/{CgConstants.XNAME_Field}[{(fieldElement.NodesBeforeSelf().OfType<XElement>().Count(e => e.Name == CgConstants.XNAME_Field) + 1)}]");
            else
            {
                string fieldXPath = $"{enumXPath}/{CgConstants.XNAME_Field}[@Name='{fieldName}']";
                XAttribute attribute = fieldElement.Attribute(CgConstants.XNAME_FullName);
                string expected = $"{typeName}.{fieldName}";
                if (attribute is null)
                {
                    WriteLine($"#warning {CgConstants.XNAME_FullName} attribute missing for {fieldXPath}");
                    fieldElement.SetAttributeValue(CgConstants.XNAME_FullName, expected);
                }
                else if (attribute.Value != expected)
                {
                    WriteLine($"#warning {CgConstants.XNAME_FullName} attribute does not match the value \"{expected}\" for {fieldXPath}");
                    fieldElement.SetAttributeValue(CgConstants.XNAME_FullName, expected);
                }
            }
        }
    }
}

foreach (XElement entityElement in entityDefinitionsElement.Elements().Elements(CgConstants.XNAME_Entity))
{
    string typeName = entityElement.Attribute(CgConstants.XNAME_Name)?.Value;
    if (string.IsNullOrWhiteSpace(typeName))
    {
        XName elementName = entityElement.Name;
        WriteLine($"#warning {CgConstants.XNAME_Name} attribute missing or empty for /{entityElement.Parent.Parent.Name}/{entityElement.Parent.Name}/{CgConstants.XNAME_Entity}[(entityElement.NodesBeforeSelf().OfType<XElement>().Count()]");
    }
    else
    {
        string typeXPath = $"/{entityElement.Parent.Parent.Name}/{entityElement.Parent.Name}/{CgConstants.XNAME_Entity}[@Name='{typeName}']";
        foreach (XElement propertyElement in entityElement.Elements(CgConstants.XNAME_Properties).Elements())
        {
            XName elementName = propertyElement.Name;
            string propertyName = propertyElement.Attribute(CgConstants.XNAME_Name)?.Value;
            if (string.IsNullOrWhiteSpace(propertyName))
                WriteLine($"#warning {CgConstants.XNAME_Name} attribute missing or empty for {typeXPath}/{elementName}[{(propertyElement.NodesBeforeSelf().OfType<XElement>().Count(e => e.Name == elementName) + 1)}]");
            else
            {
                string propertyXPath = $"{typeXPath}/{elementName}[@Name='{propertyName}']";
                XAttribute attribute = propertyElement.Attribute(CgConstants.XNAME_FullName);
                string expected = $"{typeName}.{propertyName}";
                if (attribute is null)
                {
                    WriteLine($"#warning {CgConstants.XNAME_FullName} attribute missing for {propertyXPath}");
                    propertyElement.SetAttributeValue(CgConstants.XNAME_FullName, expected);
                }
                else if (attribute.Value != expected)
                {
                    WriteLine($"#warning {CgConstants.XNAME_FullName} attribute does not match the value \"{expected}\" for {propertyXPath}");
                    propertyElement.SetAttributeValue(CgConstants.XNAME_FullName, expected);
                }
            }
        }
    }
}

PushIndent("    "); 
bool isSubsequentMember = GenerateEnumTypes(entityDefinitionsElement.Elements(CgConstants.XNAME_Root).Elements(CgConstants.XNAME_EnumTypes).Elements());
GenerateEntityTypes(entityDefinitionsElement.Elements(CgConstants.XNAME_Root).Elements(CgConstants.XNAME_Entity), isSubsequentMember);
PopIndent();

#>

    public static class DbCgConstants
    {
        public const int DbColMaxLen_SimpleName = 256;
        public const int DbColMaxLen_LongName = 1024;
        public const int DbColMaxLen_ShortName = 128;
        public const int DbColMaxLen_Identifier = 1024;
        public const int DbColMaxLen_FileName = 1024;
        public const uint DbColDefaultValue_MaxNameLength = 255;
        public const ushort DbColDefaultValue_MaxRecursionDepth = 256;
    }

}

namespace <#=DefaultNamespace#>.Local
{
<#

PushIndent("    ");
isSubsequentMember = GenerateEnumTypes(entityDefinitionsElement.Elements(CgConstants.XNAME_Local).Elements(CgConstants.XNAME_EnumTypes).Elements());
GenerateEntityTypes(entityDefinitionsElement.Elements(CgConstants.XNAME_Local).Elements(CgConstants.XNAME_Entity), isSubsequentMember);
PopIndent();

#>
}

namespace <#=DefaultNamespace#>.Upstream
{
<#

PushIndent("    ");
isSubsequentMember = GenerateEnumTypes(entityDefinitionsElement.Elements(CgConstants.XNAME_Upstream).Elements(CgConstants.XNAME_EnumTypes).Elements());
GenerateEntityTypes(entityDefinitionsElement.Elements(CgConstants.XNAME_Upstream).Elements(CgConstants.XNAME_Entity), isSubsequentMember);
PopIndent();

#>
}

<#+

void WriteAmbientValueAttribute(XElement memberElement)
{
    string ambientValue = memberElement.Elements(CgConstants.XNAME_AmbientString).Attributes(CgConstants.XNAME_Value).Select(a => a.Value).FirstOrDefault();
    if (ambientValue is not null)
    {
        Write("[AmbientValue(\"");
        Write(ambientValue.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\r", "\\r").Replace("\n", "\\n"));
        WriteLine("\")]");
        return;
    }
    foreach (XName name in new[] { CgConstants.XNAME_AmbientEnum, CgConstants.XNAME_AmbientBoolean, CgConstants.XNAME_AmbientInt })
    {
        ambientValue = memberElement.Elements(name).Attributes(CgConstants.XNAME_Value).Select(a => a.Value).FirstOrDefault();
        if (!string.IsNullOrWhiteSpace(ambientValue))
        {
            Write("[AmbientValue(");
            Write(ambientValue);
            WriteLine(")]");
            return;
        }
    }
    ambientValue = memberElement.Elements(CgConstants.XNAME_AmbientUInt).Attributes(CgConstants.XNAME_Value).Select(a => a.Value).FirstOrDefault();
    if (!string.IsNullOrWhiteSpace(ambientValue))
    {
        Write("[AmbientValue(");
        Write(ambientValue);
        WriteLine("u)]");
        return;
    }
    ambientValue = memberElement.Elements(CgConstants.XNAME_AmbientLong).Attributes(CgConstants.XNAME_Value).Select(a => a.Value).FirstOrDefault();
    if (!string.IsNullOrWhiteSpace(ambientValue))
    {
        Write("[AmbientValue(");
        Write(ambientValue);
        WriteLine("L)]");
        return;
    }
    ambientValue = memberElement.Elements(CgConstants.XNAME_AmbientULong).Attributes(CgConstants.XNAME_Value).Select(a => a.Value).FirstOrDefault();
    if (!string.IsNullOrWhiteSpace(ambientValue))
    {
        Write("[AmbientValue(");
        Write(ambientValue);
        WriteLine("UL)]");
        return;
    }
    ambientValue = memberElement.Elements(CgConstants.XNAME_AmbientDouble).Attributes(CgConstants.XNAME_Value).Select(a => a.Value).FirstOrDefault();
    if (!string.IsNullOrWhiteSpace(ambientValue))
    {
        Write("[AmbientValue(");
        Write(ambientValue);
        WriteLine(ambientValue.Contains(".") ? ")]" : ".0)]");
        return;
    }
    ambientValue = memberElement.Elements(CgConstants.XNAME_AmbientFloat).Attributes(CgConstants.XNAME_Value).Select(a => a.Value).FirstOrDefault();
    if (!string.IsNullOrWhiteSpace(ambientValue))
    {
        Write("[AmbientValue(");
        Write(ambientValue);
        WriteLine("f)]");
        return;
    }
    foreach (XName name in new[] { CgConstants.XNAME_AmbientByte, CgConstants.XNAME_AmbientSByte, CgConstants.XNAME_AmbientShort, CgConstants.XNAME_AmbientUShort })
    {
        ambientValue = memberElement.Elements(name).Attributes(CgConstants.XNAME_Value).Select(a => a.Value).FirstOrDefault();
        if (!string.IsNullOrWhiteSpace(ambientValue))
        {
            Write("[AmbientValue((");
#pragma warning disable IDE0057 // Use range operator
            Write(name.LocalName.Substring(7).ToLower());
#pragma warning restore IDE0057 // Use range operator
            Write(")");
            Write(ambientValue);
            WriteLine(")]");
            return;
        }
    }
}
void WriteDisplayAttribute(string memberName, Func<XName, IEnumerable<XAttribute>> getAttributes, string typeName = null)
{
    string displayNameResource = getAttributes(CgConstants.XNAME_DisplayNameResource).Select(a => a.Value).DefaultIfEmpty(string.IsNullOrWhiteSpace(typeName) ?
        $"DisplayName_{memberName}" : $"DisplayName_{typeName}_{memberName}").First();
    string descriptionResource = getAttributes(CgConstants.XNAME_DescriptionResource).Select(a => a.Value).FirstOrDefault();
    string resourceType = getAttributes(CgConstants.XNAME_ResourceType).Select(a => a.Value).DefaultIfEmpty("Properties.Resources").First();
    if (string.IsNullOrWhiteSpace(displayNameResource))
    {
        if (!string.IsNullOrWhiteSpace(descriptionResource))
        {
            Write("[Display(Description = nameof(");
            Write(resourceType);
            Write(".");
            Write(descriptionResource);
            WriteLine("), ResourceType = typeof(Properties.Resources))]");
        }
    }
    else
    {
        Write("[Display(Name = nameof(");
        Write(resourceType);
        Write(".");
        Write(displayNameResource);
        if (!string.IsNullOrWhiteSpace(descriptionResource))
        {
            Write("), Description = nameof(");
            Write(resourceType);
            Write(".");
            Write(descriptionResource);
        }
        Write("), ResourceType = typeof(");
        Write(resourceType);
        WriteLine("))]");
    }
}
void GenerateXmlDoc(XElement xmlDocElement)
{
    if (xmlDocElement is null)
        return;
    if (xmlDocElement.IsEmpty)
    {
        foreach (string lt in CgConstants.NewLineRegex.Split(xmlDocElement.ToString(SaveOptions.None)))
        {
            Write("/// ");
            WriteLine(lt.Trim());
        }
        return;
    }
    if (xmlDocElement.LastNode is XText lastNode)
    {
        while (lastNode.PreviousNode is XText previousTextNode)
        {
            lastNode.Value = $"{previousTextNode.Value}{lastNode.Value}";
            previousTextNode.Remove();
        }
        if (!CgConstants.TrailingEmptyLine.IsMatch(lastNode.Value))
            lastNode.Value = $"{lastNode.Value}\n";
    }
    else
    {
        lastNode = new XText("\n");
        xmlDocElement.Add(lastNode);
    }
    if (xmlDocElement.FirstNode is XText firstNode)
    {
        while (firstNode.NextNode is XText followingTextNode)
        {
            firstNode.Value = $"{firstNode.Value}{followingTextNode.Value}";
            followingTextNode.Remove();
        }
        if (ReferenceEquals(firstNode, lastNode))
        {
            if (CgConstants.LeadingEmptyLine.Match(firstNode.Value).Length < firstNode.Value.Length)
                firstNode.Value = $"\n{firstNode.Value}";
        }
        else if (!CgConstants.LeadingEmptyLine.IsMatch(firstNode.Value))
            firstNode.Value = $"\n{firstNode.Value}";
    }
    else
        xmlDocElement.FirstNode.AddBeforeSelf(new XText("\n"));
    IEnumerable<string> lines = CgConstants.NewLineRegex.Split(xmlDocElement.ToString(SaveOptions.None));
    if (!(lines.Skip(2).Any() && (lines = lines.Take(1).Concat(lines.Skip(1).SkipWhile(s => string.IsNullOrWhiteSpace(s))).ToArray()).Skip(3).Any() &&
        (lines = lines.Reverse().Take(1).Concat(lines.Reverse().Skip(1).SkipWhile(s => string.IsNullOrWhiteSpace(s))).Reverse().ToArray()).Skip(3).Any()))
    {
        Write("/// ");
        Write(lines.First());
        if (lines.Skip(2).Any())
            Write(lines.Skip(1).First().Trim());
        WriteLine(lines.Last().Trim());
        return;
    }

    if (CgConstants.LeadingWsRegex.IsMatch(lines.Skip(1).First()))
    {
        int indent = lines.Skip(1).Reverse().Skip(1).Reverse().Select(s => CgConstants.LeadingWsRegex.Match(s)).Select(m => m.Success ? m.Length : 0).Min();
        if (indent > 0)
#pragma warning disable IDE0057 // Use range operator
            lines = lines.Take(1).Concat(lines.Skip(1).Reverse().Skip(1).Reverse().Select(s => s.Substring(indent))).Concat(lines.Reverse().Take(1));
#pragma warning restore IDE0057 // Use range operator
    }
    else
    {
        int indent = lines.Skip(2).Reverse().Skip(1).Reverse().Select(s => CgConstants.LeadingWsRegex.Match(s)).Select(m => m.Success ? m.Length : 0).Min();
        if (indent > 0)
#pragma warning disable IDE0057 // Use range operator
            lines = lines.Take(2).Concat(lines.Skip(2).Reverse().Skip(1).Reverse().Select(s => s.Substring(indent))).Concat(lines.Reverse().Take(1));
#pragma warning restore IDE0057 // Use range operator
    }

    Write("/// ");
    WriteLine(lines.First());
    foreach (string s in lines.Skip(1).Reverse().Skip(1).Reverse())
    {
        Write("/// ");
        WriteLine(s.TrimEnd());
    }
    Write("/// ");
    WriteLine(lines.Last().Trim());
}
void GenerateEnumType(XElement enumElement)
{
    GenerateXmlDoc(enumElement.Element(CgConstants.XNAME_summary));
    GenerateXmlDoc(enumElement.Element(CgConstants.XNAME_remarks));
    foreach (XElement e in enumElement.Elements(CgConstants.XNAME_seealso))
    {
        if (!e.IsEmpty && e.Value.Trim().Length == 0)
            e.RemoveAll();
        GenerateXmlDoc(e);
    }
    EnumGenerationInfo generationInfo = EnumGenerationInfo.Get(enumElement);
    if (generationInfo.IsFlags)
        WriteLine("[Flags]");
    Write("public enum ");
    Write(generationInfo.Name);
    Write(" : ");
    WriteLine(generationInfo.CsTypeName);
    WriteLine("{");
    PushIndent("    ");
    bool isSubsequentMember = false;
    foreach (FieldGenerationInfo field in generationInfo.Fields)
    {
        if (isSubsequentMember)
        {
            WriteLine(",");
            WriteLine("");
            isSubsequentMember = true;
        }
        else
            isSubsequentMember = true;
        GenerateXmlDoc(field.Source.Element(CgConstants.XNAME_summary));
        GenerateXmlDoc(field.Source.Element(CgConstants.XNAME_remarks));
        foreach (XElement e in field.Source.Elements(CgConstants.XNAME_seealso))
        {
            if (!e.IsEmpty && e.Value.Trim().Length == 0)
                e.RemoveAll();
            GenerateXmlDoc(e);
        }
        WriteAmbientValueAttribute(field.Source);
        WriteDisplayAttribute(field.Name, n => field.Source.Attributes(n), generationInfo.Name);
        Write(field.Name);
        Write(" = ");
        Write(field.Value.CsCode);
    }

    PopIndent();
    WriteLine("");
    WriteLine("}");
}
bool GenerateEnumTypes(IEnumerable<XElement> enumElements)
{
    if (!enumElements.Any())
        return false;
    GenerateEnumType(enumElements.First());
    foreach (XElement typeElement in enumElements.Skip(1))
    {
        WriteLine("");
        GenerateEnumType(typeElement);
    }
    return true;
}
void GenerateEntityTypes(IEnumerable<XElement> entityElements, bool isSubsequentMember)
{
    if (isSubsequentMember)
        WriteLine("");
    GenerateEntityInterface(entityElements.First());
    foreach (XElement typeElement in entityElements.Skip(1))
    {
        WriteLine("");
        GenerateEntityInterface(typeElement);
    }
}
void GenerateProperty(string typeName, PropertyGenerationInfo property)
{
    XElement commentDocElement = property.Source.Element(CgConstants.XNAME_summary) ?? property.Inherited.Select(p => p.Source).Elements(CgConstants.XNAME_summary).FirstOrDefault();
    if (commentDocElement is null)
        WriteLine($"#warning No summary element found for {typeName}.{property.Name}");
    else
        GenerateXmlDoc(commentDocElement);
    commentDocElement = property.Source.Element(CgConstants.XNAME_value) ?? property.Inherited.Select(p => p.Source).Elements(CgConstants.XNAME_value).FirstOrDefault();
    if (commentDocElement is null)
        WriteLine($"#warning No value element found for {typeName}.{property.Name}");
    else
        GenerateXmlDoc(commentDocElement);
    commentDocElement = property.Source.Element(CgConstants.XNAME_remarks) ?? property.Inherited.Select(p => p.Source).Elements(CgConstants.XNAME_remarks).FirstOrDefault();
    if (commentDocElement is not null)
        GenerateXmlDoc(commentDocElement);
    foreach (XElement e in property.Source.Elements(CgConstants.XNAME_seealso).Concat(property.Inherited.Select(p => p.Source).Elements(CgConstants.XNAME_seealso)).Distinct())
    {
        if (!e.IsEmpty && e.Value.Trim().Length == 0)
            e.RemoveAll();
        GenerateXmlDoc(e);
    }
    WriteDisplayAttribute(property.Name, n => property.Source.Attributes(n).Concat(property.Inherited.Select(p => p.Source).Attributes(n)));
    if (property.Inherited.Count > 0)
        Write("new ");
    switch (property.Source.Name.LocalName)
    {
        case CgConstants.NAME_Byte:
        case CgConstants.NAME_SByte:
        case CgConstants.NAME_Short:
        case CgConstants.NAME_UShort:
        case CgConstants.NAME_Int:
        case CgConstants.NAME_UInt:
        case CgConstants.NAME_Long:
        case CgConstants.NAME_ULong:
        case CgConstants.NAME_Float:
        case CgConstants.NAME_Double:
            Write(property.Source.Name.LocalName.ToLower());
            Write(property.AllowNull ? "? " : " ");
            break;
        case CgConstants.NAME_Text:
        case CgConstants.NAME_NVarChar:
            Write("string ");
            break;
        case CgConstants.NAME_VolumeIdentifier:
        case CgConstants.NAME_DriveType:
        case CgConstants.NAME_MD5Hash:
        case CgConstants.NAME_DateTime:
            Write(property.Source.Name.LocalName);
            Write(property.AllowNull ? "? " : " ");
            break;
        case CgConstants.NAME_ByteValues:
        case CgConstants.NAME_MultiStringValue:
            Write(property.Source.Name.LocalName);
            Write(" ");
            break;
        case CgConstants.NAME_UniqueIdentifier:
            Write(property.AllowNull ? "Guid? " : "Guid ");
            break;
        case CgConstants.NAME_Bit:
            Write(property.AllowNull ? "bool? " : "bool ");
            break;
        case CgConstants.NAME_Enum:
            Write(property.Source.Attribute(CgConstants.XNAME_Type)?.Value);
            Write(property.AllowNull ? "? " : " ");
            break;
        case CgConstants.NAME_CollectionNavigation:
        case CgConstants.NAME_CollectionNavigation_ItemKey:
        case CgConstants.NAME_CollectionNavigation_ItemType:
            Write("IEnumerable<");
            Write(property.ReferencedType.Name);
            Write("> ");
            break;
        case CgConstants.NAME_RelatedEntity:
        case CgConstants.NAME_RelatedEntity_Key:
        case CgConstants.NAME_RelatedEntity_Type:
            Write(property.ReferencedType.Name);
            Write(" ");
            break;
        default:
            WriteLine($"#warning Unknown element: {property.Source.Name.LocalName}");
            Write("object ");
            break;
    }

    Write(property.Name);
    WriteLine(property.IsGenericWritable ? " { get; set; }" : " { get; }");
}
void GenerateEntityInterface(XElement entityElement)
{
    EntityGenerationInfo generationInfo = EntityGenerationInfo.Get(entityElement);
    XElement commentDocElement = entityElement.Element(CgConstants.XNAME_summary) ?? generationInfo.BaseTypes.Select(b => b.Entity.Source).Elements(CgConstants.XNAME_summary).FirstOrDefault();
    if (commentDocElement is null)
        WriteLine($"#warning No summary element found for {generationInfo.Name}");
    else
        GenerateXmlDoc(commentDocElement);
    foreach (XElement e in entityElement.Elements(CgConstants.XNAME_typeparam).Concat(generationInfo.BaseTypes.Select(b => b.Entity.Source).Elements(CgConstants.XNAME_typeparam)).Distinct())
        GenerateXmlDoc(e);
    commentDocElement = entityElement.Element(CgConstants.XNAME_remarks) ?? generationInfo.BaseTypes.Select(b => b.Entity.Source).Elements(CgConstants.XNAME_remarks).FirstOrDefault();
    if (commentDocElement is not null)
        GenerateXmlDoc(commentDocElement);
    foreach (XElement e in entityElement.Elements(CgConstants.XNAME_seealso).Concat(generationInfo.BaseTypes.Select(b => b.Entity.Source).Select(s => new XElement(CgConstants.XNAME_seealso, new XAttribute(CgConstants.XNAME_cref, s)))))
    {
        if (!e.IsEmpty && e.Value.Trim().Length == 0)
            e.RemoveAll();
        GenerateXmlDoc(e);
    }
    IEnumerable<PropertyGenerationInfo> properties = generationInfo.Properties.Where(p => ReferenceEquals(p.ReferencedType, generationInfo));
    Write("public interface ");
    if (generationInfo.BaseTypes.Count > 0)
    {
        Write(generationInfo.Name);
        Write(" : ");

        if (generationInfo.BaseTypes.Count > 1)
        {
            foreach ((string Name, EntityGenerationInfo Entity) t in generationInfo.BaseTypes.Reverse().Skip(1).Reverse())
            {
                Write(t.Name);
                Write(", ");
            }
        }
        if (!properties.Any())
        {
            Write(generationInfo.BaseTypes.Last().Name);
            WriteLine("{ }");
            return;
        }
        Write(generationInfo.BaseTypes.Last().Name);
    }
    else
    {
        if (!properties.Any())
        {
            Write(generationInfo.Name);
            WriteLine("{ }");
            return;
        }
        WriteLine(generationInfo.Name);
    }

    WriteLine("{");
    PushIndent("    ");

    GenerateProperty(generationInfo.Name, properties.First());
    foreach (PropertyGenerationInfo p in properties.Skip(1))
    {
        WriteLine("");
        GenerateProperty(generationInfo.Name, p);
    }

    PopIndent();
    WriteLine("}");
}

#>
