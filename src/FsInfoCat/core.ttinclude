<#+
/* Following assemblies are required:
 *     EnvDTE
 *     EnvDTE80
 *     System.Core
 *     System.Linq
 *     System.Xml
 *     System.Xml.Linq
 *     System.Xml.ReaderWriter
 * The following namespaces are required:
 *     EnvDTE
 *     EnvDTE80
 *     Microsoft.VisualStudio.TextTemplating
 *     System
 *     System.Collections.Generic
 *     System.Collections.ObjectModel
 *     System.IO
 *     System.Linq
 *     System.Reflection
 *     System.Text
 *     System.Text.RegularExpressions
 *     System.Xml
 *     System.Xml.Linq
 *     System.Xml.Schema
 */

//    XElement FindRootPropertyByFullName(string fullName); // "/EntityDefinition/Root/Entity/Properties/*"
//
//    XElement FindRootFieldByFullName(string fullName); // "/EntityDefinition/Root/EnumTypes/*/Field"
//
//    XElement FindRootMemberByFullName(string fullName); // "/EntityDefinition/Root/(Entity/Properties/*|EnumTypes/*/Field)"
//
//    XElement FindLocalPropertyByFullName(string fullName); // "/EntityDefinition/(Root|Local)/Entity/Properties/*"
//
//    XElement FindLocalFieldByFullName(string fullName); // "/EntityDefinition/(Root|Local)/EnumTypes/*/Field"
//
//    XElement FindLocalMemberByFullName(string fullName); // "/EntityDefinition/(Root|Local)/(Entity/Properties/*|EnumTypes/*/Field)"
//
//    XElement FindUpstreamPropertyByFullName(string fullName); // "/EntityDefinition/(Root|Upstream)/Entity/Properties/*"
//
//    XElement FindUpstreamFieldByFullName(string fullName); // "/EntityDefinition/(Root|Upstream)/EnumTypes/*/Field"
//
//    XElement FindUpstreamMemberByFullName(string fullName); // "/EntityDefinition/(Root|Upstream)/(Entity/Properties/*|EnumTypes/*/Field)"
//
//    "/EntityDefinitions/*/Entity/Properties/Enum""
//    XElement GetEnumPropertyEnumType(XElement enumPropertyElement); // "./@Type" => "/EntityDefinition/*/EnumTypes/*"
//
//    "/EntityDefinitions/*/Entity/Properties/Enum"
//    XElement GetEnumPropertyDefaultField(XElement enumPropertyElement); // "./Default" => "/EntityDefinition/*/EnumTypes/*/Field"
//
//    "/EntityDefinitions/*/EnumTypes/*/Field"
//    XElement GetEnumFieldAmbientEnumField(XElement enumFieldElement); // "./AmbientEnum/@Value" => "/EntityDefinitions/*/EnumTypes/*/Field"
//
//    "/EntityDefinitions/*/Entity/Properties/(CollectionNavigation|NewCollectionNavigation)"
//    XElement GetCollectionNavigationItemEntity(XElement collectionNavigationPropertyElement); // "./@ItemType" => "/EntityDefinitions/*/Entity"
//
//    "/EntityDefinitions/*/Entity"
//    IEnumerable<GetBaseEntities> GetBaseEntities(XElement entityElement); // "./((ExtendsEntity|ImplementsEntity)/@Type|(ExtendsGenericEntity|ImplementsGenericEntity)/@TypeDef)"
//                                                                            => "/EntityDefinitions/*/Entity"
//
//    "/EntityDefinitions/*/Entity/Properties/(RelatedEntity|NewRelatedEntity)"
//    XElement GetRelatedEntityKeyProperty(XElement relatedEntityPropertyElement); // "./@PrimaryKey" => "/EntityDefinitions/*/Entity"
//
//    "/EntityDefinitions/*/Entity/Properties/(CollectionNavigation|NewCollectionNavigation)"
//    XElement GetCollectionNavigationItemKeyProperty(XElement collectionNavigationPropertyElement); // "./@ForeignKey" => "/EntityDefinitions/*/Entity"

#region Entity Related Fields

const string SQL_TYPENAME_BLOB = "BLOB";
const string SQL_TYPENAME_UNIQUEIDENTIFIER = "UNIQUEIDENTIFIER";
const string SQL_TYPENAME_NVARCHAR = "NVARCHAR";
const string SQL_TYPENAME_TEXT = "TEXT";
const string SQL_TYPENAME_DATETIME = "DATETIME";
const string SQL_TYPENAME_TIME = "TIME";
const string SQL_TYPENAME_BIT = "BIT";
const string SQL_TYPENAME_VARBINARY = "VARBINARY";
const string SQL_TYPENAME_BINARY = "BINARY";
const string SQL_TYPENAME_TINYINT = "TINYINT";
const string SQL_TYPENAME_UNSIGNED_TINYINT = "UNSIGNED TINYINT";
const string SQL_TYPENAME_SMALLINT = "SMALLINT";
const string SQL_TYPENAME_UNSIGNED_SMALLINT = "UNSIGNED SMALLINT";
const string SQL_TYPENAME_INT = "INT";
const string SQL_TYPENAME_UNSIGNED_INT = "UNSIGNED INT";
const string SQL_TYPENAME_BIGINT = "BIGINT";
const string SQL_TYPENAME_UNSIGNED_BIGINT = "UNSIGNED BIGINT";
const string SQL_TYPENAME_REAL = "REAL";
const string SQL_TYPENAME_NUMERIC = "NUMERIC";
const string NAME_Root = "Root";
const string NAME_Upstream = "Upstream";
const string NAME_Local = "Local";
const string NAME_Entity = "Entity";
const string NAME_Enum = "Enum";
const string NAME_Name = "Name";
const string NAME_FullName = "FullName";
const string NAME_Field = "Field";
const string NAME_CollectionNavigation = "CollectionNavigation";
const string NAME_NewCollectionNavigation = "NewCollectionNavigation";
const string NAME_RelatedEntity = "RelatedEntity";
const string NAME_NewRelatedEntity = "NewRelatedEntity";
const string NAME_ItemType = "ItemType";
const string NAME_Reference = "Reference";
const string NAME_AmbientEnum = "AmbientEnum";
const string NAME_Default = "Default";
const string NAME_Value = "Value";
const string NAME_EnumTypes = "EnumTypes";
const string NAME_Properties = "Properties";
const string NAME_ExtendsEntity = "ExtendsEntity";
const string NAME_ExtendsGenericEntity = "ExtendsGenericEntity";
const string NAME_Implements = "Implements";
const string NAME_ImplementsEntity = "ImplementsEntity";
const string NAME_ImplementsGenericEntity = "ImplementsGenericEntity";
const string NAME_RootInterface = "RootInterface";
const string NAME_Type = "Type";
const string NAME_TypeDef = "TypeDef";
const string NAME_ItemKey = "ItemKey";
const string NAME_AmbientBoolean = "AmbientBoolean";
const string NAME_AmbientInt = "AmbientInt";
const string NAME_AmbientByte = "AmbientByte";
const string NAME_AmbientSByte = "AmbientSByte";
const string NAME_AmbientShort = "AmbientShort";
const string NAME_AmbientUShort = "AmbientUShort";
const string NAME_AmbientFloat = "AmbientFloat";
const string NAME_AmbientDouble = "AmbientDouble";
const string NAME_summary = "summary";
const string NAME_remarks = "remarks";
const string NAME_seealso = "seealso";
const string NAME_IsFlags = "IsFlags";
const string NAME_typeparam = "typeparam";
const string NAME_cref = "cref";
const string NAME_NewIdNavRef = "NewIdNavRef";
const string NAME_UniqueIdentifier = "UniqueIdentifier";
const string NAME_value = "value";
const string NAME_DefaultNull = "DefaultNull";
const string NAME_DefaultNow = "DefaultNow";
const string NAME_DefaultZero = "DefaultZero";
const string NAME_DefaultEmpty = "DefaultEmpty";
const string NAME_AllowNull = "AllowNull";
const string NAME_IsGenericWritable = "IsGenericWritable";
const string NAME_DisplayNameResource = "DisplayNameResource";
const string NAME_DescriptionResource = "DescriptionResource";
const string NAME_ResourceType = "ResourceType";
const string NAME_TableName = "TableName";
const string NAME_ColName = "ColName";
const string NAME_Byte = "Byte";
const string NAME_SByte = "SByte";
const string NAME_MultiStringValue = "MultiStringValue";
const string NAME_MD5Hash = "MD5Hash";
const string NAME_ByteValues = "ByteValues";
const string NAME_Short = "Short";
const string NAME_UShort = "UShort";
const string NAME_Int = "Int";
const string NAME_UInt = "UInt";
const string NAME_Long = "Long";
const string NAME_ULong = "ULong";
const string NAME_Double = "Double";
const string NAME_Float = "Float";
const string NAME_Decimal = "Decimal";
const string NAME_NVarChar = "NVarChar";
const string NAME_Char = "Char";
const string NAME_DateTime = "DateTime";
const string NAME_TimeSpan = "TimeSpan";
const string NAME_Bit = "Bit";
const string NAME_Text = "Text";
const string NAME_VolumeIdentifier = "VolumeIdentifier";
const string NAME_DriveType = "DriveType";
const string NAME_MaxLength = "MaxLength";
const string NAME_MinLength = "MinLength";
const string NAME_MaxValue = "MaxValue";
const string NAME_MinValue = "MinValue";
const string NAME_CreatedOn = "CreatedOn";
const string NAME_ModifiedOn = "ModifiedOn";
const string NAME_UpstreamId = "UpstreamId";
const string NAME_LastSynchronizedOn = "LastSynchronizedOn";
const string NAME_IsNormalized = "IsNormalized";
const string NAME_Index = "Index";
const string NAME_Unique = "Unique";
const string NAME_IsPrimaryKey = "IsPrimaryKey";
const string NAME_Property = "Property";
const string NAME_LeftProperty = "LeftProperty";
const string NAME_RightProperty = "RightProperty";
const string NAME_Operator = "Operator";
const string XNAME_langword = "langword";
const string XNAME_see = "see";
const string NAME_PrimaryKey = "PrimaryKey";
const string NAME_ForeignKey = "ForeignKey";
const string NAME_AmbientString = "AmbientString";
const string NAME_AmbientUInt = "AmbientUInt";
const string NAME_AmbientLong = "AmbientLong";
const string NAME_AmbientULong = "AmbientULong";
const string NAME_IsCaseSensitive = "IsCaseSensitive";
const string NAME_ConstraintName = "ConstraintName";
const string NAME_FkPropertyName = "FkPropertyName";
const string NAME_Check = "Check";
const string NAME_And = "And";
const string NAME_Or = "Or";
const string NAME_IsNull = "IsNull";
const string NAME_NotNull = "NotNull";
const string NAME_LessThan = "LessThan";
const string NAME_NotGreaterThan = "NotGreaterThan";
const string NAME_Equals = "Equals";
const string NAME_NotEquals = "NotEquals";
const string NAME_NotLessThan = "NotLessThan";
const string NAME_GreaterThan = "GreaterThan";
const string NAME_OtherProperty = "OtherProperty";
const string NAME_True = "True";
const string NAME_False = "False";
const string NAME_Now = "Now";
const string NAME_Trimmed = "Trimmed";
const string NAME_Length = "Length";
const string NAME_Navigation = "Navigation";
static readonly XName XNAME_Root = XName.Get(NAME_Root);
static readonly XName XNAME_Upstream = XName.Get(NAME_Upstream);
static readonly XName XNAME_Local = XName.Get(NAME_Local);
static readonly XName XNAME_Entity = XName.Get(NAME_Entity);
static readonly XName XNAME_Enum = XName.Get(NAME_Enum);
static readonly XName XNAME_Name = XName.Get(NAME_Name);
static readonly XName XNAME_FullName = XName.Get(NAME_FullName);
static readonly XName XNAME_Field = XName.Get(NAME_Field);
static readonly XName XNAME_CollectionNavigation = XName.Get(NAME_CollectionNavigation);
static readonly XName XNAME_NewCollectionNavigation = XName.Get(NAME_NewCollectionNavigation);
static readonly XName XNAME_RelatedEntity = XName.Get(NAME_RelatedEntity);
static readonly XName XNAME_NewRelatedEntity = XName.Get(NAME_NewRelatedEntity);
static readonly XName XNAME_ItemType = XName.Get(NAME_ItemType);
static readonly XName XNAME_Reference = XName.Get(NAME_Reference);
static readonly XName XNAME_AmbientEnum = XName.Get(NAME_AmbientEnum);
static readonly XName XNAME_Default = XName.Get(NAME_Default);
static readonly XName XNAME_Value = XName.Get(NAME_Value);
static readonly XName XNAME_EnumTypes = XName.Get(NAME_EnumTypes);
static readonly XName XNAME_Properties = XName.Get(NAME_Properties);
static readonly XName XNAME_ExtendsEntity = XName.Get(NAME_ExtendsEntity);
static readonly XName XNAME_ExtendsGenericEntity = XName.Get(NAME_ExtendsGenericEntity);
static readonly XName XNAME_Implements = XName.Get(NAME_Implements);
static readonly XName XNAME_ImplementsEntity = XName.Get(NAME_ImplementsEntity);
static readonly XName XNAME_ImplementsGenericEntity = XName.Get(NAME_ImplementsGenericEntity);
static readonly XName XNAME_RootInterface = XName.Get(NAME_RootInterface);
static readonly XName XNAME_Type = XName.Get(NAME_Type);
static readonly XName XNAME_TypeDef = XName.Get(NAME_TypeDef);
static readonly XName XNAME_ItemKey = XName.Get(NAME_ItemKey);
static readonly XName XNAME_AmbientBoolean = XName.Get(NAME_AmbientBoolean);
static readonly XName XNAME_AmbientInt = XName.Get(NAME_AmbientInt);
static readonly XName XNAME_AmbientByte = XName.Get(NAME_AmbientByte);
static readonly XName XNAME_AmbientSByte = XName.Get(NAME_AmbientSByte);
static readonly XName XNAME_AmbientShort = XName.Get(NAME_AmbientShort);
static readonly XName XNAME_AmbientUShort = XName.Get(NAME_AmbientUShort);
static readonly XName XNAME_AmbientFloat = XName.Get(NAME_AmbientFloat);
static readonly XName XNAME_AmbientDouble = XName.Get(NAME_AmbientDouble);
static readonly XName XNAME_summary = XName.Get(NAME_summary);
static readonly XName XNAME_remarks = XName.Get(NAME_remarks);
static readonly XName XNAME_seealso = XName.Get(NAME_seealso);
static readonly XName XNAME_IsFlags = XName.Get(NAME_IsFlags);
static readonly XName XNAME_typeparam = XName.Get(NAME_typeparam);
static readonly XName XNAME_cref = XName.Get(NAME_cref);
static readonly XName XNAME_NewIdNavRef = XName.Get(NAME_NewIdNavRef);
static readonly XName XNAME_UniqueIdentifier = XName.Get(NAME_UniqueIdentifier);
static readonly XName XNAME_value = XName.Get(NAME_value);
static readonly XName XNAME_DefaultNull = XName.Get(NAME_DefaultNull);
static readonly XName XNAME_DefaultNow = XName.Get(NAME_DefaultNow);
static readonly XName XNAME_DefaultZero = XName.Get(NAME_DefaultZero);
static readonly XName XNAME_AllowNull = XName.Get(NAME_AllowNull);
static readonly XName XNAME_IsGenericWritable = XName.Get(NAME_IsGenericWritable);
static readonly XName XNAME_DisplayNameResource = XName.Get(NAME_DisplayNameResource);
static readonly XName XNAME_DescriptionResource = XName.Get(NAME_DescriptionResource);
static readonly XName XNAME_ResourceType = XName.Get(NAME_ResourceType);
static readonly XName XNAME_TableName = XName.Get(NAME_TableName);
static readonly XName XNAME_ColName = XName.Get(NAME_ColName);
static readonly XName XNAME_Byte = XName.Get(NAME_Byte);
static readonly XName XNAME_SByte = XName.Get(NAME_SByte);
static readonly XName XNAME_MultiStringValue = XName.Get(NAME_MultiStringValue);
static readonly XName XNAME_MD5Hash = XName.Get(NAME_MD5Hash);
static readonly XName XNAME_ByteValues = XName.Get(NAME_ByteValues);
static readonly XName XNAME_Short = XName.Get(NAME_Short);
static readonly XName XNAME_UShort = XName.Get(NAME_UShort);
static readonly XName XNAME_Int = XName.Get(NAME_Int);
static readonly XName XNAME_UInt = XName.Get(NAME_UInt);
static readonly XName XNAME_Long = XName.Get(NAME_Long);
static readonly XName XNAME_ULong = XName.Get(NAME_ULong);
static readonly XName XNAME_Double = XName.Get(NAME_Double);
static readonly XName XNAME_Float = XName.Get(NAME_Float);
static readonly XName XNAME_Decimal = XName.Get(NAME_Decimal);
static readonly XName XNAME_NVarChar = XName.Get(NAME_NVarChar);
static readonly XName XNAME_Char = XName.Get(NAME_Char);
static readonly XName XNAME_DateTime = XName.Get(NAME_DateTime);
static readonly XName XNAME_TimeSpan = XName.Get(NAME_TimeSpan);
static readonly XName XNAME_Bit = XName.Get(NAME_Bit);
static readonly XName XNAME_Text = XName.Get(NAME_Text);
static readonly XName XNAME_VolumeIdentifier = XName.Get(NAME_VolumeIdentifier);
static readonly XName XNAME_DriveType = XName.Get(NAME_DriveType);
static readonly XName XNAME_MaxLength = XName.Get(NAME_MaxLength);
static readonly XName XNAME_CreatedOn = XName.Get(NAME_CreatedOn);
static readonly XName XNAME_ModifiedOn = XName.Get(NAME_ModifiedOn);
static readonly XName XNAME_UpstreamId = XName.Get(NAME_UpstreamId);
static readonly XName XNAME_LastSynchronizedOn = XName.Get(NAME_LastSynchronizedOn);
static readonly XName XNAME_IsNormalized = XName.Get(NAME_IsNormalized);
static readonly XName XNAME_MinLength = XName.Get(NAME_MinLength);
static readonly XName XNAME_MaxValue = XName.Get(NAME_MaxValue);
static readonly XName XNAME_MinValue = XName.Get(NAME_MinValue);
static readonly XName XNAME_Index = XName.Get(NAME_Index);
static readonly XName XNAME_DefaultEmpty = XName.Get(NAME_DefaultEmpty);
static readonly XName XNAME_Unique = XName.Get(NAME_Unique);
static readonly XName XNAME_IsPrimaryKey = XName.Get(NAME_IsPrimaryKey);
static readonly XName XNAME_Property = XName.Get(NAME_Property);
static readonly XName XNAME_LeftProperty = XName.Get(NAME_LeftProperty);
static readonly XName XNAME_RightProperty = XName.Get(NAME_RightProperty);
static readonly XName XNAME_Operator = XName.Get(NAME_Operator);
static readonly XName XNAME_PrimaryKey = XName.Get(NAME_PrimaryKey);
static readonly XName XNAME_ForeignKey = XName.Get(NAME_ForeignKey);
static readonly XName XNAME_AmbientString = XName.Get(NAME_AmbientString);
static readonly XName XNAME_AmbientUInt = XName.Get(NAME_AmbientUInt);
static readonly XName XNAME_AmbientLong = XName.Get(NAME_AmbientLong);
static readonly XName XNAME_AmbientULong = XName.Get(NAME_AmbientULong);
static readonly XName XNAME_IsCaseSensitive = XName.Get(NAME_IsCaseSensitive);
static readonly XName XNAME_ConstraintName = XName.Get(NAME_ConstraintName);
static readonly XName XNAME_FkPropertyName = XName.Get(NAME_FkPropertyName);
static readonly XName XNAME_Check = XName.Get(NAME_Check);
static readonly XName XNAME_And = XName.Get(NAME_And);
static readonly XName XNAME_Or = XName.Get(NAME_Or);
static readonly XName XNAME_IsNull = XName.Get(NAME_IsNull);
static readonly XName XNAME_NotNull = XName.Get(NAME_NotNull);
static readonly XName XNAME_LessThan = XName.Get(NAME_LessThan);
static readonly XName XNAME_NotGreaterThan = XName.Get(NAME_NotGreaterThan);
static readonly XName XNAME_Equals = XName.Get(NAME_Equals);
static readonly XName XNAME_NotEquals = XName.Get(NAME_NotEquals);
static readonly XName XNAME_NotLessThan = XName.Get(NAME_NotLessThan);
static readonly XName XNAME_GreaterThan = XName.Get(NAME_GreaterThan);
static readonly XName XNAME_OtherProperty = XName.Get(NAME_OtherProperty);
static readonly XName XNAME_True = XName.Get(NAME_True);
static readonly XName XNAME_False = XName.Get(NAME_False);
static readonly XName XNAME_Now = XName.Get(NAME_Now);
static readonly XName XNAME_Trimmed = XName.Get(NAME_Trimmed);
static readonly XName XNAME_Length = XName.Get(NAME_Length);
static readonly XName XNAME_Navigation = XName.Get(NAME_Navigation);
static readonly Regex NewLineRegex = new(@"\r\n?|[\n\p{Zl}\p{Zp}]", RegexOptions.Compiled);
static readonly Regex NormalizeWsRegex = new(@" ((?![\r\n])\s)*|(?! )((?![\r\n])\s)+", RegexOptions.Compiled);
static readonly Regex NormalizeNewLineRegex = new(@"[\v\t\p{Zl}\p{Zp}]|\r(?!\n)", RegexOptions.Compiled);
static readonly Regex TrimOuterBlankLinesRegex = new(@"^(\s*(\r\n?|\n))+|((\r\n?|\n)\s*)+$", RegexOptions.Compiled);
static readonly Regex StripWsRegex = new(@"^ [ \t\u0085\p{Zs}]+(?=[\r\n\v\t\p{Zl}\p{Zp}])|(?<=[\r\n\v\t\p{Zl}\p{Zp}])[ \t\u0085\p{Zs}]+", RegexOptions.Compiled);
static readonly Regex LeadingWsRegex = new(@"^\s+", RegexOptions.Compiled);
static readonly Regex LeadingEmptyLine = new(@"^([^\r\n\S]+)?(\r\n?|\n)", RegexOptions.Compiled);
static readonly Regex TrailingEmptyLine = new(@"(\r\n?|\n)([^\r\n\S]+)?$", RegexOptions.Compiled);
static readonly Regex TrailingWsRegex = new(@"\s+$", RegexOptions.Compiled);

#endregion

private static string _templateFolder = null;
private static EnvDTE.DTE _dte = null;
private static EnvDTE.Solution _solution = null;
private static EnvDTE.ProjectItem _templateItem = null;
private static EnvDTE.Project _currentProject = null;
private static ProjectInfoObject _projectInfo = null;
private static string _defaultNamespace = null;
private XDocument _entityDefinitionsDocument;

List<ValidationEventArgs> ValidationErrors { get; } = new();

XDocument EntityDefinitionsDocument
{
    get
    {
        if (_entityDefinitionsDocument is null)
        {
            XmlReaderSettings readerSettings = new XmlReaderSettings();
            readerSettings.Schemas.Add("", Path.Combine(Path.GetDirectoryName(Solution.FullName), "FsInfoCat\\Resources\\EntityDefinitions.xsd"));
            readerSettings.ValidationType = ValidationType.Schema;
            readerSettings.ValidationEventHandler += XmlValidationEventHandler;
            using XmlReader reader = XmlReader.Create(Path.Combine(Path.GetDirectoryName(Solution.FullName), "FsInfoCat\\Resources\\EntityDefinitions.xml"), readerSettings);
            _entityDefinitionsDocument = XDocument.Load(reader, LoadOptions.PreserveWhitespace);
        }
        return _entityDefinitionsDocument;
    }
}

void XmlValidationEventHandler(object sender, ValidationEventArgs e) { ValidationErrors.Add(e); }

#region Entity-Related Methods

IEnumerable<XElement> AllRootEntityElements => EntityDefinitionsDocument.Root?.Elements(XNAME_Root).Elements(XNAME_Entity);
IEnumerable<XElement> AllRootEnumTypeElements => EntityDefinitionsDocument.Root?.Elements(XNAME_Root).Elements(XNAME_EnumTypes).Elements();
IEnumerable<XElement> AllRootPropertyElements => AllRootEntityElements.Elements(XNAME_Properties).Elements();
IEnumerable<XElement> AllRootEnumFieldElements => AllRootEnumTypeElements.Elements(XNAME_Field);
IEnumerable<XElement> AllLocalEntityElements => AllRootEntityElements.Concat(EntityDefinitionsDocument.Root?.Elements(XNAME_Local).Elements(XNAME_Entity));
IEnumerable<XElement> AllLocalEnumTypeElements => AllRootEnumTypeElements.Concat(EntityDefinitionsDocument.Root?.Elements(XNAME_Local).Elements(XNAME_EnumTypes).Elements());
IEnumerable<XElement> AllLocalPropertyElements => AllRootPropertyElements.Concat(AllLocalEntityElements.Elements(XNAME_Properties).Elements());
IEnumerable<XElement> AllLocalEnumFieldElements => AllRootEnumFieldElements.Concat(AllLocalEnumTypeElements.Elements(XNAME_Properties).Elements());
IEnumerable<XElement> AllUpstreamEntityElements => AllRootEntityElements.Concat(EntityDefinitionsDocument.Root?.Elements(XNAME_Upstream).Elements(XNAME_Entity));
IEnumerable<XElement> AllUpstreamEnumTypeElements => AllRootEnumTypeElements.Concat(EntityDefinitionsDocument.Root?.Elements(XNAME_Upstream).Elements(XNAME_EnumTypes).Elements());
IEnumerable<XElement> AllUpstreamPropertyElements => AllRootPropertyElements.Concat(AllUpstreamEntityElements.Elements(XNAME_Properties).Elements());
IEnumerable<XElement> AllUpstreamEnumFieldElements => AllRootEnumFieldElements.Concat(AllUpstreamEnumTypeElements.Elements(XNAME_Properties).Elements());
static bool? FromXmlBoolean(string xml)
{
    if (string.IsNullOrWhiteSpace(xml))
        return null;
    try { return XmlConvert.ToBoolean(xml); }
    catch { return null; }
}
static int? FromXmlInt32(string xml)
{
    if (string.IsNullOrWhiteSpace(xml))
        return null;
    try { return XmlConvert.ToInt32(xml); }
    catch { return null; }
}
static DateTime? FromXmlDateTime(string xml)
{
    if (string.IsNullOrWhiteSpace(xml))
        return null;
    try { return XmlConvert.ToDateTime(xml, XmlDateTimeSerializationMode.RoundtripKind); }
    catch { return null; }
}
static TimeSpan? FromXmlTimeSpan(string xml)
{
    if (string.IsNullOrWhiteSpace(xml))
        return null;
    try { return XmlConvert.ToTimeSpan(xml); }
    catch { return null; }
}
static Guid? FromXmlGuid(string xml)
{
    if (string.IsNullOrWhiteSpace(xml))
        return null;
    try { return XmlConvert.ToGuid(xml); }
    catch { return null; }
}
static byte[] FromXmlBinary(string xml)
{
    if (xml is null)
        return null;
    if ((xml = xml.Trim()).Length > 0)
        try { return Convert.FromBase64String(xml); }
        catch { return null; }
    return Array.Empty<byte>();
}
static TValue GetAnnotatedCacheValue<TCache, TValue>(XElement target, Func<TCache> ifNotExist)
    where TCache : class, IElementCacheItem<TValue>
{
    if (target is null)
        return default;
    TCache cacheItem = target.Annotation<TCache>();
    if (cacheItem is null)
    {
        cacheItem = ifNotExist();
        target.AddAnnotation(cacheItem);
    }
    return cacheItem.Value;
}
static IEnumerable<XElement> GetElementsByNames(XElement source, params XName[] names)
{
    if (names is null || names.Length == 0)
        return source.Elements();
    if (names.Length > 1)
        return source.Elements().Where(e => names.Any(n => e.Name == n));
    return source.Elements(names[0]);
}
static IEnumerable<XElement> GetElementsByName(IEnumerable<XElement> source, params XName[] names)
{
    if (names is null || names.Length == 0)
        return source.Elements();
    if (names.Length > 1)
        return source.Elements().Where(e => names.Any(n => e.Name == n));
    return source.Elements(names[0]);
}
static IEnumerable<XElement> GetElementsByAttributeValue(XName name, string value, IEnumerable<XElement> source) => (value is null || source is null || !source.Any()) ?
    Enumerable.Empty<XElement>() : source.Attributes(name).Where(a => a.Value == value).Select(a => a.Parent);
static IEnumerable<XElement> GetElementsByAttributeValue(XName name, IEnumerable<string> values, IEnumerable<XElement> source) =>
    (values is null || source is null || !values.Any() || !source.Any()) ? Enumerable.Empty<XElement>() :
    values.Distinct().SelectMany(v => source.Attributes(name).Where(a => a.Value == v)).Select(a => a.Parent);
XElement FindRootEntityByName(string name) => GetElementsByAttributeValue(XNAME_Name, name, AllRootEntityElements).FirstOrDefault();
XElement FindRootEnumTypeByName(string name) => GetElementsByAttributeValue(XNAME_Name, name, AllRootEnumTypeElements).FirstOrDefault();
XElement FindLocalEntityByName(string name) => GetElementsByAttributeValue(XNAME_Name, name, AllLocalEntityElements).FirstOrDefault();
XElement FindLocalEnumTypeByName(string name) => GetElementsByAttributeValue(XNAME_Name, name, AllLocalEnumTypeElements).FirstOrDefault();
XElement FindUpstreamEntityByName(string name) => GetElementsByAttributeValue(XNAME_Name, name, AllUpstreamEntityElements).FirstOrDefault();
XElement FindUpstreamEnumTypeByName(string name) => GetElementsByAttributeValue(XNAME_Name, name, AllUpstreamEnumTypeElements).FirstOrDefault();
XElement FindRootPropertyByFullName(string fullName) => GetElementsByAttributeValue(XNAME_FullName, fullName, AllRootPropertyElements).FirstOrDefault();
XElement FindRootFieldByFullName(string fullName) => GetElementsByAttributeValue(XNAME_FullName, fullName, AllRootEnumFieldElements).FirstOrDefault();
XElement FindLocalPropertyByFullName(string fullName) => GetElementsByAttributeValue(XNAME_FullName, fullName, AllLocalPropertyElements).FirstOrDefault();
XElement FindLocalFieldByFullName(string fullName) => GetElementsByAttributeValue(XNAME_FullName, fullName, AllLocalEnumFieldElements).FirstOrDefault();
XElement FindUpstreamPropertyByFullName(string fullName) => GetElementsByAttributeValue(XNAME_FullName, fullName, AllUpstreamPropertyElements).FirstOrDefault();
XElement FindUpstreamFieldByFullName(string fullName) => GetElementsByAttributeValue(XNAME_FullName, fullName, AllUpstreamEnumFieldElements).FirstOrDefault();
static bool IsEntityElement(XElement element) => element?.Name == XNAME_Entity;
static bool IsEnumTypeElement(XElement element) => element?.Parent?.Name == XNAME_EnumTypes;
static bool IsPropertyElement(XElement element) => element?.Parent?.Name == XNAME_Properties;
static bool IsEnumFieldElement(XElement element) => element?.Name == XNAME_Field;
static XElement GetScopeElement(XElement refElement)
{
    XElement root = refElement.Document?.Root;
    return (root is null) ? null : refElement.AncestorsAndSelf().FirstOrDefault(e => ReferenceEquals(root, e.Parent));
}
static IEnumerable<XElement> GetAllEntityElements(XElement refElement)
{
    XElement scopeElement = GetScopeElement(refElement);
    if (scopeElement is null)
        return Enumerable.Empty<XElement>();
    if (scopeElement.Name != XNAME_Root)
        return scopeElement.Elements(XNAME_Entity).Concat(scopeElement.Ancestors().Take(1).Elements(XNAME_Root).Elements(XNAME_Entity));
    return scopeElement.Elements(XNAME_Entity);
}
static IEnumerable<XElement> GetAllPropertyElements(XElement refElement) => GetAllEntityElements(refElement).Elements(XNAME_Properties).Elements();
static IEnumerable<XElement> GetAllEnumTypeElements(XElement refElement)
{
    XElement scopeElement = GetScopeElement(refElement);
    if (scopeElement is null)
        return Enumerable.Empty<XElement>();
    if (scopeElement.Name != XNAME_Root)
    {
        XElement rootElement = scopeElement.Parent?.Element(XNAME_Root);
        if (rootElement is not null)
            return scopeElement.Elements(XNAME_EnumTypes).Concat(scopeElement.Ancestors().Take(1).Elements(XNAME_Root).Elements(XNAME_EnumTypes)).Elements();
    }
    return scopeElement.Elements(XNAME_EnumTypes).Elements();
}
static IEnumerable<XElement> GetAllEnumFieldElements(XElement refElement) => GetAllEnumTypeElements(refElement).Elements(XNAME_Field);
static XElement FindEntityByName(XElement refElement, string name) => GetElementsByAttributeValue(XNAME_Name, name, GetAllEntityElements(refElement)).FirstOrDefault();
static IEnumerable<XElement> FindEntitiesByNames(XElement refElement, IEnumerable<string> names) => GetElementsByAttributeValue(XNAME_Name, names, GetAllEntityElements(refElement));
static XElement FindEnumTypeByName(XElement refElement, string name) => GetElementsByAttributeValue(XNAME_Name, name, GetAllEnumTypeElements(refElement)).FirstOrDefault();
static XElement FindPropertyByFullName(XElement refElement, string fullName) => GetElementsByAttributeValue(XNAME_FullName, fullName, GetAllPropertyElements(refElement)).FirstOrDefault();
static XElement FindFieldByFullName(XElement refElement, string fullName) => GetElementsByAttributeValue(XNAME_FullName, fullName, GetAllEnumFieldElements(refElement)).FirstOrDefault();
static XElement GetEnumType(XElement enumPropertyElement) => GetAnnotatedCacheValue<EnumTypeCacheItem, XElement>(enumPropertyElement,
    () => new EnumTypeCacheItem(FindEnumTypeByName(enumPropertyElement, enumPropertyElement?.Attribute(XNAME_Name)?.Value)));
static XElement GetDefaultValueField(XElement enumPropertyElement) => GetAnnotatedCacheValue<DefaultValueCacheItem<XElement>, XElement>(enumPropertyElement,
    () => new DefaultValueCacheItem<XElement>((enumPropertyElement?.Name == XNAME_Enum) ?
        FindFieldByFullName(enumPropertyElement, enumPropertyElement.Element(XNAME_Default)?.Value) : null));
static XElement GetAmbientValueField(XElement enumFieldElement) => GetAnnotatedCacheValue<RelatedValueCacheItem<XElement>, XElement>(enumFieldElement,
    () => new RelatedValueCacheItem<XElement>((enumFieldElement?.Name == XNAME_Field) ?
        FindFieldByFullName(enumFieldElement, enumFieldElement.Elements(XNAME_AmbientEnum).Attributes(XNAME_Value).Select(a => a.Value).FirstOrDefault()) : null));
static XElement GetRelatedEntity(XElement relatedEntityPropertyElement)
{
    if (relatedEntityPropertyElement is null || (relatedEntityPropertyElement.Name != XNAME_RelatedEntity && relatedEntityPropertyElement.Name != XNAME_NewRelatedEntity))
        return null;
    return GetAnnotatedCacheValue<RelatedValueCacheItem<XElement>, XElement>(relatedEntityPropertyElement, () =>
        new RelatedValueCacheItem<XElement>(FindEntityByName(relatedEntityPropertyElement, relatedEntityPropertyElement.Attribute(XNAME_Reference)?.Value)));
}
static XElement GetItemEntity(XElement collectionNavigationPropertyElement)
{
    if (collectionNavigationPropertyElement is null || (collectionNavigationPropertyElement.Name != XNAME_CollectionNavigation &&
            collectionNavigationPropertyElement.Name != XNAME_NewCollectionNavigation))
        return null;
    return GetAnnotatedCacheValue<RelatedValueCacheItem<XElement>, XElement>(collectionNavigationPropertyElement, () =>
    {
        XElement itemTypeElement = collectionNavigationPropertyElement.Element(XNAME_ItemType);
        return new RelatedValueCacheItem<XElement>((itemTypeElement is null) ?
            FindPropertyByFullName(collectionNavigationPropertyElement, collectionNavigationPropertyElement.Element(XNAME_ItemKey)?.Value)?.Parent :
            FindEntityByName(itemTypeElement, itemTypeElement.Value));
    });
}
static XElement[] GetBaseEntities(XElement entityElement)
{
    if (entityElement is null || entityElement.Name != XNAME_Entity)
        return Array.Empty<XElement>();
    return GetAnnotatedCacheValue<ImmediateBaseValuesCacheItem<XElement>, XElement[]>(entityElement, () =>
        new ImmediateBaseValuesCacheItem<XElement>(FindEntitiesByNames(entityElement, entityElement.Elements(XNAME_ExtendsEntity).Attributes(XNAME_Type)
            .Concat(entityElement.Elements(XNAME_ExtendsGenericEntity).Attributes(XNAME_TypeDef))
            .Concat(entityElement.Attributes(XNAME_RootInterface))
            .Concat(entityElement.Elements().Select(e => (e.Name == XNAME_ImplementsEntity) ? e.Attribute(XNAME_Type) :
                (e.Name == XNAME_ImplementsGenericEntity) ? e.Attribute(XNAME_TypeDef) : null).Where(a => a is not null))
            .Select(a => a.Value)).ToArray()));
}
static AllBaseValuesCacheItem<XElement>  GetAllBaseEntitiesCachItem(XElement entityElement)
{
    List<XElement> result = GetBaseEntities(entityElement).ToList();
    if (result.Count == 0)
        return new AllBaseValuesCacheItem<XElement>(Array.Empty<XElement>());
    foreach (XElement element in result.SelectMany((e, n) => GetAllBaseEntities(e).Select((e, i) => (e, i + result.Count + n))).OrderBy(t => t.Item2).Select(t => t.e).ToArray())
    {
        if (!result.Any(e => ReferenceEquals(e, element)))
            result.Add(element);
    }
    return new AllBaseValuesCacheItem<XElement>(result.ToArray());
}
static XElement[] GetAllBaseEntities(XElement entityElement)
{
    if (entityElement is null || entityElement.Name != XNAME_Entity)
        return Array.Empty<XElement>();
    return GetAnnotatedCacheValue<AllBaseValuesCacheItem<XElement>, XElement[]>(entityElement, () => GetAllBaseEntitiesCachItem(entityElement));
}
static XElement[] GetProperties(XElement entityElement) => (entityElement is null || entityElement.Name != XNAME_Entity) ? Array.Empty<XElement>() :
    GetAnnotatedCacheValue<ImmediateMembersCacheItem<XElement>, XElement[]>(entityElement,
        () => new ImmediateMembersCacheItem<XElement>(entityElement.Elements(XNAME_Properties).Elements().ToArray()));
static (string Name, List<XElement> Sources)[] GetAllProperties(XElement entityElement)
{
    if (entityElement is null || entityElement.Name != XNAME_Entity)
        return Array.Empty<(string Name, List<XElement> Sources)>();
    return GetAnnotatedCacheValue<AllMembersCacheItem<(string Name, List<XElement> Sources)>, (string Name, List<XElement> Sources)[]>(entityElement, () =>
    {
        List<(string Name, List<XElement> Sources)> results = new();
        foreach ((string Name, List<XElement> Sources) p in GetAllBaseEntities(entityElement).Reverse().SelectMany(e => GetAllProperties(e)))
        {
            if (results.Any(t => t.Name == p.Name))
            {
                List<XElement> sources = results.First(t => t.Name == p.Name).Sources;
                foreach (XElement s in p.Sources)
                {
                    if (!sources.Any(e => ReferenceEquals(s, e)))
                        sources.Add(s);
                }
            }
            else
                results.Add(p);
        }
        foreach (XElement element in GetProperties(entityElement))
        {
            string name = element.Attribute(XNAME_Name)?.Value ?? "";
            if (results.Any(t => t.Name == name))
            {
                List<XElement> sources = results.First(t => t.Name == name).Sources;
                if (!sources.Any(e => ReferenceEquals(element, e)))
                    sources.Add(element);
            }
            else
            {
                List<XElement> sources = new();
                sources.Add(element);
                results.Add((name, sources));
            }
        }
        return new AllMembersCacheItem<(string Name, List<XElement> Sources)>(results.ToArray());
    });
}
static AllBasePropertiesCacheItem GetAllBasePropertiesCacheItem(XElement propertyElement)
{
    string propertyName = propertyElement?.Attribute(XNAME_Name)?.Value;
    XElement[] allBaseEntities;
    if ((allBaseEntities = GetAllBaseEntities(propertyElement.Parent?.Parent)).Length == 0)
        return new AllBasePropertiesCacheItem(new PropertyInheritanceInfo(propertyElement, false, false, Array.Empty<XElement>(), propertyElement));
    XName baseName;
    bool n, e;
    switch (propertyElement.Name.LocalName)
    {
        case NAME_NewIdNavRef:
            n = false;
            e = true;
            baseName = XNAME_UniqueIdentifier;
            break;
        case NAME_NewRelatedEntity:
            n = true;
            e = false;
            baseName = XNAME_RelatedEntity;
            break;
        case NAME_NewCollectionNavigation:
            n = true;
            e = false;
            baseName = XNAME_CollectionNavigation;
            break;
        default:
            return new AllBasePropertiesCacheItem(new PropertyInheritanceInfo(propertyElement, false, false,
                GetElementsByAttributeValue(XNAME_Name, propertyName, allBaseEntities.Elements(XNAME_Properties).Elements()).ToArray(), propertyElement));
    }
    IEnumerable<XElement> results = GetElementsByAttributeValue(XNAME_Name, propertyName, allBaseEntities.Elements(XNAME_Properties).Elements());
    return new AllBasePropertiesCacheItem(new PropertyInheritanceInfo(results.Where(e => e.Name == baseName).DefaultIfEmpty(propertyElement).First(), n, e,
        results.ToArray(), propertyElement));
}
static PropertyInheritanceInfo GetAllBaseProperties(XElement propertyElement)
{
    if (propertyElement is null || propertyElement.Parent?.Name != XNAME_Properties)
        return new PropertyInheritanceInfo(propertyElement, false, true, Array.Empty<XElement>(), propertyElement);
    return GetAnnotatedCacheValue<AllBasePropertiesCacheItem, PropertyInheritanceInfo>(propertyElement, () => GetAllBasePropertiesCacheItem(propertyElement));
}
static XText ToWhiteSpaceNormalized(XText source)
{
    string text = source.Value;
    if (NormalizeNewLineRegex.IsMatch(text))
        text = NormalizeNewLineRegex.Replace(text, Environment.NewLine);
    if (TrimOuterBlankLinesRegex.IsMatch(text))
        text = TrimOuterBlankLinesRegex.Replace(text, Environment.NewLine);
    if (NormalizeWsRegex.IsMatch(text))
        text = NormalizeWsRegex.Replace(text, " ");
    return new XText(StripWsRegex.IsMatch(text) ? StripWsRegex.Replace(text, "") : text);
}
static XElement WsNormalizedWithoutElementNamespace(XElement sourceParent)
{
    if (sourceParent.Name.LocalName == XNAME_langword)
        return new XElement(XNamespace.None.GetName(XNAME_see), new XAttribute(XNAME_langword, sourceParent.Value));
    XElement resultElement = new(XNamespace.None.GetName(sourceParent.Name.LocalName));
    foreach (XAttribute attribute in sourceParent.Attributes())
        resultElement.Add(new XAttribute(attribute));
    XNode sourceNode = sourceParent.Nodes().FirstOrDefault(n => n is XElement || n is XText t && !string.IsNullOrWhiteSpace(t.Value));
    if (sourceNode is null)
        return resultElement;
    if (sourceNode is XText text)
        resultElement.Add(ToWhiteSpaceNormalized(text));
    else
        resultElement.Add(WsNormalizedWithoutElementNamespace((XElement)sourceNode));
    while ((sourceNode = sourceNode.NodesAfterSelf().FirstOrDefault(n => n is XElement || n is XText t && (!string.IsNullOrWhiteSpace(t.Value) || (t.NextNode is not null && t.NextNode is not XText)))) is not null)
    {
        if (sourceNode is XText xText)
            resultElement.Add(ToWhiteSpaceNormalized(xText));
        else
            resultElement.Add(WsNormalizedWithoutElementNamespace((XElement)sourceNode));
    }
    return resultElement;
}
static XElement WithoutElementNamespace(XElement sourceParent)
{
    if (sourceParent.Name.LocalName == XNAME_langword)
        return new XElement(XNamespace.None.GetName(XNAME_see), new XAttribute(XNAME_langword, sourceParent.Value));
    XElement resultElement = new(XNamespace.None.GetName(sourceParent.Name.LocalName));
    foreach (XAttribute attribute in sourceParent.Attributes())
        resultElement.Add(new XAttribute(attribute));
    XNode sourceNode = sourceParent.Nodes().FirstOrDefault(n => n is XElement || n is XText t && !string.IsNullOrWhiteSpace(t.Value));
    if (sourceNode is null)
        return resultElement;
    if (sourceNode is XText text)
        resultElement.Add(new XText(text));
    else
        resultElement.Add(WithoutElementNamespace((XElement)sourceNode));
    while ((sourceNode = sourceNode.NodesAfterSelf().FirstOrDefault(n => n is XElement || n is XText t && (!string.IsNullOrWhiteSpace(t.Value) || (t.NextNode is not null && t.NextNode is not XText)))) is not null)
    {
        if (sourceNode is XText xText)
            resultElement.Add(new XText(xText));
        else
            resultElement.Add(WithoutElementNamespace((XElement)sourceNode));
    }
    return resultElement;
}
static Type ToUnderlyingType(Type type)
{
    if (type is null)
        return null;
    Type e;
    if (type.HasElementType)
    {
        e = type.GetElementType();
        if (e.IsArray || e.IsPointer)
            return type;
        if (type.IsArray || type.IsPointer)
            return ToUnderlyingType(e).MakeArrayType();
        return ToUnderlyingType(e);
    }

    if (type.IsValueType)
    {
        if (type.IsGenericType && typeof(Nullable<>).IsAssignableFrom(type.GetGenericTypeDefinition()))
            return ToUnderlyingType(Nullable.GetUnderlyingType(type));
        if (type.IsEnum)
            type = Enum.GetUnderlyingType(type);
        if (type.IsPrimitive || type == typeof(decimal) || type == typeof(DateTime) || type == typeof(DateTimeOffset) || type == typeof(TimeSpan) || type == typeof(Guid))
            return type;
    }
    else
    {
        if (type == typeof(string))
            return type;
        if (type == typeof(Uri))
            return typeof(string);
    }
    e = type.GetInterfaces().Where(i => i.IsGenericType && typeof(IEnumerable<>) == i.GetGenericTypeDefinition()).Select(i => i.GetGenericArguments()[0]).FirstOrDefault();
    if (e is not null)
    {
        Type u = ToUnderlyingType(e);
        if (u.IsPrimitive || u == typeof(string) || u == typeof(decimal) || u == typeof(DateTime) || u == typeof(DateTimeOffset) || u == typeof(TimeSpan) || u == typeof(Guid))
            return u.MakeArrayType();
        return e.MakeArrayType();
    }
    return type;
}
static int FindPrimeNumber(int startValue)
{
    try
    {
        if ((Math.Abs(startValue) & 1) == 0)
            startValue++;
        while (!IsPrimeNumber(startValue))
            startValue += 2;
    }
    catch (OverflowException) { return 1; }
    return startValue;
}
static bool IsPrimeNumber(int value)
{
    if (((value = Math.Abs(value)) & 1) == 0)
        return false;
    for (int i = value >> 1; i > 1; i--)
    {
        if (value % i == 0)
            return false;
    }
    return true;
}
interface IElementCacheItem<T> { T Value { get; } }
public class DefaultValueCacheItem<T> : IElementCacheItem<T> { public T Value { get; } public DefaultValueCacheItem(T value) { Value = value; } }
public class EnumTypeCacheItem : IElementCacheItem<XElement> { public XElement Value { get; } public EnumTypeCacheItem(XElement value) { Value = value; } }
public class RelatedValueCacheItem<T> : IElementCacheItem<T> { public T Value { get; } public RelatedValueCacheItem(T value) { Value = value; } }
public class ImmediateBaseValuesCacheItem<T> : IElementCacheItem<T[]> { public T[] Value { get; } public ImmediateBaseValuesCacheItem(T[] value) { Value = value; } }
public class AllBaseValuesCacheItem<T> : IElementCacheItem<T[]> { public T[] Value { get; } public AllBaseValuesCacheItem(T[] value) { Value = value; } }
public class ImmediateMembersCacheItem<T> : IElementCacheItem<T[]> { public T[] Value { get; } public ImmediateMembersCacheItem(T[] value) { Value = value; } }
public class AllMembersCacheItem<T> : IElementCacheItem<T[]> { public T[] Value { get; } public AllMembersCacheItem(T[] value) { Value = value; } }
public class PropertyInheritanceInfo
{
    public XElement BaseDefinitionElement { get; }
    public bool IsNew { get; }
    public bool DoNotEmit { get; }
    public XElement[] InheritedProperties { get; }
    public XElement Source { get; }
    public PropertyInheritanceInfo(XElement baseDefinitionElement, bool isNew, bool doNotEmit, XElement[] inheritedProperties, XElement source)
    {
        BaseDefinitionElement = baseDefinitionElement;
        IsNew = isNew;
        DoNotEmit = doNotEmit;
        InheritedProperties = inheritedProperties;
        Source = source;
    }
}
public class AllBasePropertiesCacheItem : IElementCacheItem<PropertyInheritanceInfo> { public PropertyInheritanceInfo Value { get; } public AllBasePropertiesCacheItem(PropertyInheritanceInfo value) { Value = value; } }

#endregion

string TemplateFolder
{
	get
	{
		if (_templateFolder == null)
			_templateFolder = Path.GetDirectoryName(Host.TemplateFile);
		return _templateFolder;
	}
}

string DefaultNamespace
{
	get
	{
		if (_defaultNamespace != null)
			return _defaultNamespace;
		_defaultNamespace = GetCurrentItemPropertyString("CustomToolNamespace");
		if (!String.IsNullOrEmpty(_defaultNamespace))
			return _defaultNamespace;
		try
		{
			_defaultNamespace = System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")?.ToString();
			if (!String.IsNullOrEmpty(_defaultNamespace))
				return _defaultNamespace;
		}
		catch { }
		_defaultNamespace = GetCurrentItemPropertyString("RootNamespace");
		if (String.IsNullOrEmpty(_defaultNamespace))
			_defaultNamespace = (String.IsNullOrEmpty(ProjectInfo.DefaultNamespace)) ? ProjectInfo.RootNamespace ?? "" : ProjectInfo.DefaultNamespace;
		return _defaultNamespace;
	}
}

EnvDTE.DTE DTE
{
	get
	{
		if (_dte == null)
			_dte = (EnvDTE.DTE)((Host as IServiceProvider).GetService(typeof(EnvDTE.DTE)));
		return _dte;
	}
}

EnvDTE.Solution Solution
{
	get
	{
		if (_solution == null)
			_solution = DTE.Solution;
		return _solution;
	}
}

EnvDTE.ProjectItem TemplateItem
{
	get
	{
		if (_templateItem == null)
			_templateItem = Solution.FindProjectItem(Host.TemplateFile);
		return _templateItem;
	}
}

EnvDTE.Project CurrentProject
{
	get
	{
		if (_currentProject == null)
			_currentProject = TemplateItem.ContainingProject;
		return _currentProject;
	}
}

ProjectInfoObject ProjectInfo
{
	get
	{
		if (_projectInfo == null)
			_projectInfo = new ProjectInfoObject(CurrentProject);
		return _projectInfo;
	}
}

string CustomToolOutput { get { return GetCurrentItemPropertyString("CustomToolOutput"); } }

string ActiveConfig { get { return GetPropertyString(Solution.Properties, "ActiveConfig"); } }

IEnumerable<FileInfo> GetProjectItemFiles(EnvDTE.ProjectItem pi)
{
	for (int i = 0; i < pi.FileCount; i++)
		yield return new System.IO.FileInfo(pi.FileNames[(short)(i + 1)]);
}

IEnumerable<FileInfo> GetProjectFiles(Func<EnvDTE.ProjectItem, System.IO.FileInfo, bool> predicate = null)
{
	IEnumerable<EnvDTE.ProjectItem> items = CurrentProject.ProjectItems.OfType<EnvDTE.ProjectItem>().Where(pi => ProjectInfo.FileKind.Equals(new Guid(pi.Kind)));

	if (predicate == null)
		return items.SelectMany(pi => GetProjectItemFiles(pi));

	return items.SelectMany(pi => GetProjectItemFiles(pi).Where(fi => predicate(pi, fi)));
}

IEnumerable<FileInfo> GetCodeProjectFiles() { return GetProjectFiles((EnvDTE.ProjectItem pi, System.IO.FileInfo fi) => pi.FileCodeModel != null); }

IEnumerable<FileInfo> GetNonCodeProjectFiles() { return GetProjectFiles((EnvDTE.ProjectItem pi, System.IO.FileInfo fi) => pi.FileCodeModel == null); }
/*
XText ToWhiteSpaceNormalized(XText source)
{
    string text = source.Value;
    if (NormalizeNewLineRegex.IsMatch(text))
        text = NormalizeNewLineRegex.Replace(text, Environment.NewLine);
    if (TrimOuterBlankLinesRegex.IsMatch(text))
        text = TrimOuterBlankLinesRegex.Replace(text, Environment.NewLine);
    if (NormalizeWsRegex.IsMatch(text))
        text = NormalizeWsRegex.Replace(text, " ");
    return new XText(StripWsRegex.IsMatch(text) ? StripWsRegex.Replace(text, "") : text);
}

XElement WsNormalizedWithoutElementNamespace(XElement sourceParent)
{
    if (sourceParent.Name.LocalName == "langword")
        return new XElement(XNamespace.None.GetName(XNAME_see), new XAttribute("langword", sourceParent.Value));
    XElement resultElement = new XElement(XNamespace.None.GetName(sourceParent.Name.LocalName));
    foreach (XAttribute attribute in sourceParent.Attributes())
        resultElement.Add(new XAttribute(attribute));
    XNode sourceNode = sourceParent.Nodes().FirstOrDefault(n => n is XElement || n is XText t && !string.IsNullOrWhiteSpace(t.Value));
    if (sourceNode is null)
        return resultElement;
    if (sourceNode is XText text)
        resultElement.Add(ToWhiteSpaceNormalized(text));
    else
        resultElement.Add(WsNormalizedWithoutElementNamespace((XElement)sourceNode));
    while ((sourceNode = sourceNode.NodesAfterSelf().FirstOrDefault(n => n is XElement || n is XText t && (!string.IsNullOrWhiteSpace(t.Value) || (t.NextNode is not null && t.NextNode is not XText)))) is not null)
    {
        if (sourceNode is XText xText)
            resultElement.Add(ToWhiteSpaceNormalized(xText));
        else
            resultElement.Add(WsNormalizedWithoutElementNamespace((XElement)sourceNode));
    }
    return resultElement;
}

XElement WithoutElementNamespace(XElement sourceParent)
{
    if (sourceParent.Name.LocalName == "langword")
        return new XElement(XNamespace.None.GetName(XNAME_see), new XAttribute("langword", sourceParent.Value));
    XElement resultElement = new XElement(XNamespace.None.GetName(sourceParent.Name.LocalName));
    foreach (XAttribute attribute in sourceParent.Attributes())
        resultElement.Add(new XAttribute(attribute));
    XNode sourceNode = sourceParent.Nodes().FirstOrDefault(n => n is XElement || n is XText t && !string.IsNullOrWhiteSpace(t.Value));
    if (sourceNode is null)
        return resultElement;
    if (sourceNode is XText text)
        resultElement.Add(new XText(text));
    else
        resultElement.Add(WithoutElementNamespace((XElement)sourceNode));
    while ((sourceNode = sourceNode.NodesAfterSelf().FirstOrDefault(n => n is XElement || n is XText t && (!string.IsNullOrWhiteSpace(t.Value) || (t.NextNode is not null && t.NextNode is not XText)))) is not null)
    {
        if (sourceNode is XText xText)
            resultElement.Add(new XText(xText));
        else
            resultElement.Add(WithoutElementNamespace((XElement)sourceNode));
    }
    return resultElement;
}

IEnumerable<XElement> GetByNames(XElement source, params XName[] names) => names.SelectMany(n => source.Elements(n));

string[] ToXmlLines(IEnumerable<XElement> elements)
{
    if (elements is null || !elements.Any())
        return Array.Empty<string>();
    using StringWriter stringWriter = new StringWriter();
    XDocument doc = new XDocument(new XElement(WsNormalizedWithoutElementNamespace(elements.First())));
    using (XmlWriter writer = XmlWriter.Create(stringWriter, new XmlWriterSettings() { Indent = true, OmitXmlDeclaration = true }))
    {
        doc.WriteTo(writer);
        writer.Flush();
    }
    foreach (XElement e in elements.Skip(1))
    {
        stringWriter.WriteLine();
        using XmlWriter xmlWriter = XmlWriter.Create(stringWriter, new XmlWriterSettings() { Indent = true, OmitXmlDeclaration = true });
        doc = new XDocument(new XElement(WsNormalizedWithoutElementNamespace(e)));
        doc.WriteTo(xmlWriter);
        xmlWriter.Flush();
    }
    string result = stringWriter.ToString();
    string[] lines = NewLineRegex.IsMatch(result) ? NewLineRegex.Split(result) : new string[] { result };
    int trimLength = lines.Select(t => LeadingWsRegex.Match(t)).Select(m => m.Success ? m.Length : 0).Min();
    return (trimLength > 0) ? lines.Select(t => t.Substring(trimLength)).ToArray() : lines;
}

Type ToUnderlyingType(Type type)
{
    if (type is null)
        return null;
    Type e;
    if (type.HasElementType)
    {
        e = type.GetElementType();
        if (e.IsArray || e.IsPointer)
            return type;
        if (type.IsArray || type.IsPointer)
            return ToUnderlyingType(e).MakeArrayType();
        return ToUnderlyingType(e);
    }

    if (type.IsValueType)
    {
        if (type.IsGenericType && typeof(Nullable<>).IsAssignableFrom(type.GetGenericTypeDefinition()))
            return ToUnderlyingType(Nullable.GetUnderlyingType(type));
        if (type.IsEnum)
            type = Enum.GetUnderlyingType(type);
        if (type.IsPrimitive || type == typeof(decimal) || type == typeof(DateTime) || type == typeof(DateTimeOffset) || type == typeof(TimeSpan) || type == typeof(Guid))
            return type;
    }
    else
    {
        if (type == typeof(string))
            return type;
        if (type == typeof(Uri))
            return typeof(string);
    }
    e = type.GetInterfaces().Where(i => i.IsGenericType && typeof(IEnumerable<>) == i.GetGenericTypeDefinition()).Select(i => i.GetGenericArguments()[0]).FirstOrDefault();
    if (e is not null)
    {
        Type u = ToUnderlyingType(e);
        if (u.IsPrimitive || u == typeof(string) || u == typeof(decimal) || u == typeof(DateTime) || u == typeof(DateTimeOffset) || u == typeof(TimeSpan) || u == typeof(Guid))
            return u.MakeArrayType();
        return e.MakeArrayType();
    }
    return type;
}

string ToSqlTypeName(Type type, out string fullName, out Type dbCompatible)
{
    if (type is null)
    {
        fullName = "NULL";
        dbCompatible = null;
        return fullName;
    }
    dbCompatible = ToUnderlyingType(type);
    if (dbCompatible.IsPrimitive)
    {
        if (dbCompatible == typeof(char))
        {
            fullName = "CHARACTER(1)";
            return "CHARACTER";
        }
        if (dbCompatible == typeof(bool))
            fullName = "BIT";
        else if (dbCompatible == typeof(byte))
            fullName = "UNSIGNED TINYINT";
        else if (dbCompatible == typeof(sbyte))
            fullName = "TINYINT";
        else if (dbCompatible == typeof(short))
            fullName = "SMALLINT";
        else if (dbCompatible == typeof(ushort))
            fullName = "UNSIGNED SMALLINT";
        else if (dbCompatible == typeof(int))
            fullName = "INT";
        else if (dbCompatible == typeof(uint))
            fullName = "UNSIGNED INT";
        else if (dbCompatible == typeof(long))
            fullName = "BIGINT";
        else if (dbCompatible == typeof(ulong))
            fullName = "UNSIGNED BIGINT";
        else
            fullName = "REAL";
    }
    else if (dbCompatible == typeof(decimal))
        fullName = "NUMERIC";
    else if (dbCompatible == typeof(DateTime))
        fullName = "DATETIME";
    else if (dbCompatible == typeof(DateTimeOffset))
        fullName = "DATETIMEOFFSET";
    else if (dbCompatible == typeof(TimeSpan))
        fullName = "TIME";
    else if (dbCompatible == typeof(Guid))
        fullName = "UNIQUEIDENTIFIER";
    else if (dbCompatible == typeof(string))
        fullName = "TEXT";
    else
        fullName = "BLOB";
    return fullName;
}

bool TryGetRange(Type type, out object minValue, out object maxValue)
{
    if (type.HasElementType)
        type = type.GetElementType();
    if (type.IsGenericType && typeof(Nullable<>).IsAssignableFrom(type.GetGenericTypeDefinition()))
        type = ToUnderlyingType(Nullable.GetUnderlyingType(type));
    if (type == typeof(string))
    {
        minValue = maxValue = null;
        return false;
    }
    if (type.IsEnum)
    {
        Array values = Enum.GetValues(type);
        Array.Sort(values);
        minValue = values.GetValue(0);
        if (type.GetCustomAttribute<FlagsAttribute>() is null)
            maxValue = values.GetValue(values.Length - 1);
        else if (type == typeof(byte))
            maxValue = Enum.ToObject(type, values.Cast<byte>().Aggregate((x, y) => (byte)(x | y)));
        else if (type == typeof(sbyte))
            maxValue = Enum.ToObject(type, values.Cast<sbyte>().Aggregate((x, y) => (sbyte)(x | y)));
        else if (type == typeof(short))
            maxValue = Enum.ToObject(type, values.Cast<short>().Aggregate((x, y) => (short)(x | y)));
        else if (type == typeof(ushort))
            maxValue = Enum.ToObject(type, values.Cast<ushort>().Aggregate((x, y) => (ushort)(x | y)));
        else if (type == typeof(int))
            maxValue = Enum.ToObject(type, values.Cast<int>().Aggregate((x, y) => x | y));
        else if (type == typeof(uint))
            maxValue = Enum.ToObject(type, values.Cast<uint>().Aggregate((x, y) => x | y));
        else if (type == typeof(ulong))
            maxValue = Enum.ToObject(type, values.Cast<ulong>().Aggregate((x, y) => x | y));
        else
            maxValue = Enum.ToObject(type, values.Cast<long>().Aggregate((x, y) => x | y));
        return true;
    }
    if (type.IsPrimitive)
    {
        if (type == typeof(byte))
        {
            minValue = byte.MinValue;
            maxValue = byte.MaxValue;
        }
        else if (type == typeof(sbyte))
        {
            minValue = sbyte.MinValue;
            maxValue = sbyte.MaxValue;
        }
        else if (type == typeof(short))
        {
            minValue = short.MinValue;
            maxValue = short.MaxValue;
        }
        else if (type == typeof(ushort))
        {
            minValue = ushort.MinValue;
            maxValue = ushort.MaxValue;
        }
        else if (type == typeof(int))
        {
            minValue = int.MinValue;
            maxValue = int.MaxValue;
        }
        else if (type == typeof(uint))
        {
            minValue = uint.MinValue;
            maxValue = uint.MaxValue;
        }
        else if (type == typeof(long))
        {
            minValue = long.MinValue;
            maxValue = long.MaxValue;
        }
        else if (type == typeof(ulong))
        {
            minValue = ulong.MinValue;
            maxValue = ulong.MaxValue;
        }
        else if (type == typeof(float))
        {
            minValue = float.MinValue;
            maxValue = float.MaxValue;
        }
        else
        {
            minValue = maxValue = null;
            return false;
        }
        return true;
    }

    Type e = type.GetInterfaces().Where(i => i.IsGenericType && typeof(IEnumerable<>) == i.GetGenericTypeDefinition()).Select(i => i.GetGenericArguments()[0]).FirstOrDefault();
    if (e is not null && e.IsValueType)
        return TryGetRange(e, out minValue, out maxValue);
    minValue = maxValue = null;
    return false;
}
*/

internal static T GetProperty<T>(EnvDTE.Properties properties, string key, T defaultValue = default(T))
{
	try { return (T)(properties.Item(key).Value); }
	catch { return defaultValue; }
}

internal static Version GetPropertyVersion(EnvDTE.Properties properties, string key, Version defaultValue = null)
{
	string s = GetProperty<string>(properties, key);
	Version v;
	if (String.IsNullOrEmpty(s) || !Version.TryParse(s.Trim(), out v))
		return defaultValue;

	if (v.Revision != 0)
		return v;

	if (v.Build == 0)
		return new Version(v.Major, v.Minor);

	return new Version(v.Major, v.Minor, v.Build);
}

internal static Guid? GetPropertyGuid(EnvDTE.Properties properties, string key, Guid? defaultValue = null)
{
	string s = GetProperty<string>(properties, key);
	Guid g;
	if (String.IsNullOrEmpty(s) || !Guid.TryParse(s.Trim(), out g))
		return defaultValue;

	return g;
}

internal static string GetPropertyString(EnvDTE.Properties properties, string key, string defaultValue = null)
{
	string s = GetProperty<string>(properties, key);
	if (defaultValue == null || !String.IsNullOrEmpty(s))
		return s;
	return defaultValue;
}

T GetCurrentItemProperty<T>(string key, T defaultValue = default(T))
{
	return GetProperty<T>(TemplateItem.Properties, key, defaultValue);
}

string GetCurrentItemPropertyString(string key, string defaultValue = null)
{
	return GetPropertyString(TemplateItem.Properties, key, defaultValue);
}

Version GetCurrentItemPropertyVersion(string key, Version defaultValue = null)
{
	return GetPropertyVersion(TemplateItem.Properties, key, defaultValue);
}

Guid? GetCurrentItemPropertyGuid(string key, Guid? defaultValue = null)
{
	return GetPropertyGuid(TemplateItem.Properties, key, defaultValue);
}

class ProjectInfoObject
{
	internal string Title { get { return GetProjectPropertyString("Title", ""); } }
	internal string Product { get { return GetProjectPropertyString("Product", ""); } }
	internal string Name { get { return _project.Name; } }
	internal string Description { get { return GetProjectPropertyString("Description", ""); } }
	internal string Copyright { get { return GetProjectPropertyString("Copyright", ""); } }
	internal string Company { get { return GetProjectPropertyString("Company", ""); } }

	internal string RootNamespace { get { return GetProjectPropertyString("RootNamespace", ""); } }
	internal Version AssemblyVersion { get { return GetProjectPropertyVersion("AssemblyVersion"); } }
	internal string FileName { get { return GetProjectPropertyString("FileName", ""); } }
	internal string ApplicationIcon { get { return GetProjectPropertyString("ApplicationIcon", ""); } }
	internal string OutputFileName { get { return GetProjectPropertyString("OutputFileName", ""); } }
	internal Guid? AssemblyGuid { get { return GetProjectPropertyGuid("AssemblyGuid"); } }
	internal string FullPath { get { return GetProjectPropertyString("FullPath", ""); } }
	internal Version AssemblyFileVersion { get { return GetProjectPropertyVersion("AssemblyFileVersion"); } }
	internal string AssemblyName { get { return GetProjectPropertyString("AssemblyName", ""); } }
	internal string LocalPath { get { return GetProjectPropertyString("LocalPath", ""); } }
	internal string DefaultNamespace { get { return GetProjectPropertyString("DefaultNamespace", ""); } }

	internal string FullName { get { return _project.FullName; } }
	internal string SolutionName { get { return GetProjectPropertyString("SolutionName", ""); } }
	internal string TargetFileName { get { return GetProjectPropertyString("TargetFileName", ""); } }
	internal string TargetFrameworkName { get { return (TargetFrameworkMoniker.Keys[0] != null) ? TargetFrameworkMoniker.Keys[0] : ""; } }
	internal Version TargetFrameworkVersion
	{
		get
		{
			Version v;
			if (!String.IsNullOrEmpty(TargetFrameworkMoniker["Version"]) && Version.TryParse((TargetFrameworkMoniker["Version"].StartsWith("v")) ? TargetFrameworkMoniker["Version"].Substring(1) : TargetFrameworkMoniker["Version"], out v))
				return v;

			return null;
		}
	}
	internal Guid FileKind
	{
		get
		{
			Guid g;
			if (Guid.TryParse(EnvDTE.Constants.vsProjectItemKindPhysicalFile, out g))
				return g;
			throw new Exception(String.Format("\"{0}\" (from EnvDTE.Constants.vsProjectItemKindPhysicalFile) is not a valid Guid.", EnvDTE.Constants.vsProjectItemKindPhysicalFile));
		}
	}
	internal System.Collections.Specialized.NameValueCollection TargetFrameworkMoniker
	{
		get
		{
			if (_targetFrameworkMoniker == null)
			{
				_targetFrameworkMoniker = new System.Collections.Specialized.NameValueCollection();
				System.Text.RegularExpressions.Regex keyValueRegex = new System.Text.RegularExpressions.Regex(@"(^|,)(?<k>[^=,]*)(=(?<v>[^,]*))?");
				string s = GetProjectPropertyString("TargetFrameworkMoniker") ?? "";
				foreach (System.Text.RegularExpressions.Match m in keyValueRegex.Matches(s.Trim()))
				{
					if (m.Groups["v"].Success)
						_targetFrameworkMoniker.Add(m.Groups["k"].Value, m.Groups["v"].Value);
					else
						_targetFrameworkMoniker.Add(m.Groups["k"].Value, null);
				}
			}

			return _targetFrameworkMoniker;
		}
	}
	private EnvDTE.Project _project;
	private System.Collections.Specialized.NameValueCollection _targetFrameworkMoniker = null;

	internal ProjectInfoObject(EnvDTE.Project project)
	{
		_project = project;
	}
	internal T GetProjectProperty<T>(string key, T defaultValue = default(T))
	{
		return GetProperty<T>(_project.Properties, key, defaultValue);
	}
	internal string GetProjectPropertyString(string key, string defaultValue = null)
	{
		return GetPropertyString(_project.Properties, key, defaultValue);
	}
	internal Version GetProjectPropertyVersion(string key, Version defaultValue = null)
	{
		return GetPropertyVersion(_project.Properties, key, defaultValue);
	}
	internal Guid? GetProjectPropertyGuid(string key, Guid? defaultValue = null)
	{
		return GetPropertyGuid(_project.Properties, key, defaultValue);
	}
}

#>
