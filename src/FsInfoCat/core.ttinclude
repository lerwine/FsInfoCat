<#+
/* Following assemblies are required:
 *     EnvDTE
 *     EnvDTE80
 *     System.Core
 *     System.Linq
 *     System.Xml
 *     System.Xml.Linq
 *     System.Xml.ReaderWriter
 * The following namespaces are required:
 *     EnvDTE
 *     EnvDTE80
 *     Microsoft.VisualStudio.TextTemplating
 *     System
 *     System.Collections.Generic
 *     System.Collections.ObjectModel
 *     System.IO
 *     System.Linq
 *     System.Reflection
 *     System.Text
 *     System.Text.RegularExpressions
 *     System.Xml
 *     System.Xml.Linq
 *     System.Xml.Schema
 */

//    XElement FindRootPropertyByFullName(string fullName); // "/EntityDefinition/Root/Entity/Properties/*"
//
//    XElement FindRootFieldByFullName(string fullName); // "/EntityDefinition/Root/EnumTypes/*/Field"
//
//    XElement FindRootMemberByFullName(string fullName); // "/EntityDefinition/Root/(Entity/Properties/*|EnumTypes/*/Field)"
//
//    XElement FindLocalPropertyByFullName(string fullName); // "/EntityDefinition/(Root|Local)/Entity/Properties/*"
//
//    XElement FindLocalFieldByFullName(string fullName); // "/EntityDefinition/(Root|Local)/EnumTypes/*/Field"
//
//    XElement FindLocalMemberByFullName(string fullName); // "/EntityDefinition/(Root|Local)/(Entity/Properties/*|EnumTypes/*/Field)"
//
//    XElement FindUpstreamPropertyByFullName(string fullName); // "/EntityDefinition/(Root|Upstream)/Entity/Properties/*"
//
//    XElement FindUpstreamFieldByFullName(string fullName); // "/EntityDefinition/(Root|Upstream)/EnumTypes/*/Field"
//
//    XElement FindUpstreamMemberByFullName(string fullName); // "/EntityDefinition/(Root|Upstream)/(Entity/Properties/*|EnumTypes/*/Field)"
//
//    "/EntityDefinitions/*/Entity/Properties/Enum""
//    XElement GetEnumPropertyEnumType(XElement enumPropertyElement); // "./@Type" => "/EntityDefinition/*/EnumTypes/*"
//
//    "/EntityDefinitions/*/Entity/Properties/Enum"
//    XElement GetEnumPropertyDefaultField(XElement enumPropertyElement); // "./Default" => "/EntityDefinition/*/EnumTypes/*/Field"
//
//    "/EntityDefinitions/*/EnumTypes/*/Field"
//    XElement GetEnumFieldAmbientEnumField(XElement enumFieldElement); // "./AmbientEnum/@Value" => "/EntityDefinitions/*/EnumTypes/*/Field"
//
//    "/EntityDefinitions/*/Entity/Properties/(CollectionNavigation|NewCollectionNavigation)"
//    XElement GetCollectionNavigationItemEntity(XElement collectionNavigationPropertyElement); // "./@ItemType" => "/EntityDefinitions/*/Entity"
//
//    "/EntityDefinitions/*/Entity"
//    IEnumerable<GetBaseEntities> GetBaseEntities(XElement entityElement); // "./((ExtendsEntity|ImplementsEntity)/@Type|(ExtendsGenericEntity|ImplementsGenericEntity)/@TypeDef)"
//                                                                            => "/EntityDefinitions/*/Entity"
//
//    "/EntityDefinitions/*/Entity/Properties/(RelatedEntity|NewRelatedEntity)"
//    XElement GetRelatedEntityPrimaryKeyProperty(XElement relatedEntityPropertyElement); // "./@PrimaryKey" => "/EntityDefinitions/*/Entity"
//
//    "/EntityDefinitions/*/Entity/Properties/(CollectionNavigation|NewCollectionNavigation)"
//    XElement GetCollectionNavigationForeignKeyProperty(XElement collectionNavigationPropertyElement); // "./@ForeignKey" => "/EntityDefinitions/*/Entity"

static readonly Regex NewLineRegex = new Regex(@"\r\n?|[\n\p{Zl}\p{Zp}]", RegexOptions.Compiled);
static readonly Regex NormalizeWsRegex = new Regex(@" ((?![\r\n])\s)*|(?! )((?![\r\n])\s)+", RegexOptions.Compiled);
static readonly Regex NormalizeNewLineRegex = new Regex(@"[\v\t\p{Zl}\p{Zp}]|\r(?!\n)", RegexOptions.Compiled);
static readonly Regex TrimOuterBlankLinesRegex = new Regex(@"^(\s*(\r\n?|\n))+|((\r\n?|\n)\s*)+$", RegexOptions.Compiled);
static readonly Regex StripWsRegex = new Regex(@"^ [ \t\u0085\p{Zs}]+(?=[\r\n\v\t\p{Zl}\p{Zp}])|(?<=[\r\n\v\t\p{Zl}\p{Zp}])[ \t\u0085\p{Zs}]+", RegexOptions.Compiled);
static readonly Regex LeadingWsRegex = new Regex(@"^\s+", RegexOptions.Compiled);
static readonly Regex LeadingEmptyLine = new Regex(@"^([^\r\n\S]+)?(\r\n?|\n)", RegexOptions.Compiled);
static readonly Regex TrailingEmptyLine = new Regex(@"(\r\n?|\n)([^\r\n\S]+)?$", RegexOptions.Compiled);
static readonly Regex TrailingWsRegex = new Regex(@"\s+$", RegexOptions.Compiled);
const string NAME_Root = "Root";
const string NAME_Upstream = "Upstream";
const string NAME_Local = "Local";
const string NAME_Entity = "Entity";
const string NAME_Enum = "Enum";
const string NAME_Name = "Name";
const string NAME_FullName = "FullName";
const string NAME_Field = "Field";
const string NAME_CollectionNavigation = "CollectionNavigation";
const string NAME_NewCollectionNavigation = "NewCollectionNavigation";
const string NAME_RelatedEntity = "RelatedEntity";
const string NAME_NewRelatedEntity = "NewRelatedEntity";
const string NAME_ItemType = "ItemType";
const string NAME_Reference = "Reference";
const string NAME_AmbientEnum = "AmbientEnum";
const string NAME_Default = "Default";
const string NAME_Value = "Value";
const string NAME_EnumTypes = "EnumTypes";
const string NAME_Properties = "Properties";
const string NAME_ExtendsEntity = "ExtendsEntity";
const string NAME_ExtendsGenericEntity = "ExtendsGenericEntity";
const string NAME_Implements = "Implements";
const string NAME_ImplementsEntity = "ImplementsEntity";
const string NAME_ImplementsGenericEntity = "ImplementsGenericEntity";
const string NAME_RootInterface = "RootInterface";
const string NAME_Type = "Type";
const string NAME_TypeDef = "TypeDef";
const string NAME_PrimaryKey = "PrimaryKey";
const string NAME_ForeignKey = "ForeignKey";
const string NAME_AmbientBoolean = "AmbientBoolean";
const string NAME_AmbientInt = "AmbientInt";
const string NAME_AmbientByte = "AmbientByte";
const string NAME_AmbientSByte = "AmbientSByte";
const string NAME_AmbientShort = "AmbientShort";
const string NAME_AmbientUShort = "AmbientUShort";
const string NAME_AmbientFloat = "AmbientFloat";
const string NAME_AmbientDouble = "AmbientDouble";
const string NAME_summary = "summary";
const string NAME_remarks = "remarks";
const string NAME_seealso = "seealso";
const string NAME_IsFlags = "IsFlags";
const string NAME_typeparam = "typeparam";
const string NAME_cref = "cref";
const string NAME_NewIdNavRef = "NewIdNavRef";
const string NAME_UniqueIdentifier = "UniqueIdentifier";
const string NAME_value = "value";
const string NAME_DefaultNull = "DefaultNull";
const string NAME_AllowNull = "AllowNull";
const string NAME_IsGenericWritable = "IsGenericWritable";
const string NAME_DisplayNameResource = "DisplayNameResource";
const string NAME_DescriptionResource = "DescriptionResource";
const string NAME_ResourceType = "ResourceType";
const string NAME_TableName = "TableName";
const string NAME_ColName = "ColName";
const string NAME_Byte = "Byte";
const string NAME_SByte = "SByte";
const string NAME_ByteArray = "ByteArray";
const string NAME_MultiStringValue = "MultiStringValue";
const string NAME_MD5Hash = "MD5Hash";
const string NAME_ByteValues = "ByteValues";
const string NAME_Short = "Short";
const string NAME_UShort = "UShort";
const string NAME_Int = "Int";
const string NAME_UInt = "UInt";
const string NAME_Long = "Long";
const string NAME_ULong = "ULong";
const string NAME_Double = "Double";
const string NAME_Float = "Float";
const string NAME_Decimal = "Decimal";
const string NAME_NVarChar = "NVarChar";
const string NAME_Char = "Char";
const string NAME_DateTime = "DateTime";
const string NAME_TimeSpan = "TimeSpan";
const string NAME_Bit = "Bit";
const string NAME_Text = "Text";
const string NAME_VolumeIdentifier = "VolumeIdentifier";
const string NAME_DriveType = "DriveType";
const string NAME_MaxLength = "MaxLength";
static readonly XName XNAME_Root = XName.Get(NAME_Root);
static readonly XName XNAME_Upstream = XName.Get(NAME_Upstream);
static readonly XName XNAME_Local = XName.Get(NAME_Local);
static readonly XName XNAME_Entity = XName.Get(NAME_Entity);
static readonly XName XNAME_Enum = XName.Get(NAME_Enum);
static readonly XName XNAME_Name = XName.Get(NAME_Name);
static readonly XName XNAME_FullName = XName.Get(NAME_FullName);
static readonly XName XNAME_Field = XName.Get(NAME_Field);
static readonly XName XNAME_CollectionNavigation = XName.Get(NAME_CollectionNavigation);
static readonly XName XNAME_NewCollectionNavigation = XName.Get(NAME_NewCollectionNavigation);
static readonly XName XNAME_RelatedEntity = XName.Get(NAME_RelatedEntity);
static readonly XName XNAME_NewRelatedEntity = XName.Get(NAME_NewRelatedEntity);
static readonly XName XNAME_ItemType = XName.Get(NAME_ItemType);
static readonly XName XNAME_Reference = XName.Get(NAME_Reference);
static readonly XName XNAME_AmbientEnum = XName.Get(NAME_AmbientEnum);
static readonly XName XNAME_Default = XName.Get(NAME_Default);
static readonly XName XNAME_Value = XName.Get(NAME_Value);
static readonly XName XNAME_EnumTypes = XName.Get(NAME_EnumTypes);
static readonly XName XNAME_Properties = XName.Get(NAME_Properties);
static readonly XName XNAME_ExtendsEntity = XName.Get(NAME_ExtendsEntity);
static readonly XName XNAME_ExtendsGenericEntity = XName.Get(NAME_ExtendsGenericEntity);
static readonly XName XNAME_Implements = XName.Get(NAME_Implements);
static readonly XName XNAME_ImplementsEntity = XName.Get(NAME_ImplementsEntity);
static readonly XName XNAME_ImplementsGenericEntity = XName.Get(NAME_ImplementsGenericEntity);
static readonly XName XNAME_RootInterface = XName.Get(NAME_RootInterface);
static readonly XName XNAME_Type = XName.Get(NAME_Type);
static readonly XName XNAME_TypeDef = XName.Get(NAME_TypeDef);
static readonly XName XNAME_PrimaryKey = XName.Get(NAME_PrimaryKey);
static readonly XName XNAME_ForeignKey = XName.Get(NAME_ForeignKey);
static readonly XName XNAME_AmbientBoolean = XName.Get(NAME_AmbientBoolean);
static readonly XName XNAME_AmbientInt = XName.Get(NAME_AmbientInt);
static readonly XName XNAME_AmbientByte = XName.Get(NAME_AmbientByte);
static readonly XName XNAME_AmbientSByte = XName.Get(NAME_AmbientSByte);
static readonly XName XNAME_AmbientShort = XName.Get(NAME_AmbientShort);
static readonly XName XNAME_AmbientUShort = XName.Get(NAME_AmbientUShort);
static readonly XName XNAME_AmbientFloat = XName.Get(NAME_AmbientFloat);
static readonly XName XNAME_AmbientDouble = XName.Get(NAME_AmbientDouble);
static readonly XName XNAME_summary = XName.Get(NAME_summary);
static readonly XName XNAME_remarks = XName.Get(NAME_remarks);
static readonly XName XNAME_seealso = XName.Get(NAME_seealso);
static readonly XName XNAME_IsFlags = XName.Get(NAME_IsFlags);
static readonly XName XNAME_typeparam = XName.Get(NAME_typeparam);
static readonly XName XNAME_cref = XName.Get(NAME_cref);
static readonly XName XNAME_NewIdNavRef = XName.Get(NAME_NewIdNavRef);
static readonly XName XNAME_UniqueIdentifier = XName.Get(NAME_UniqueIdentifier);
static readonly XName XNAME_value = XName.Get(NAME_value);
static readonly XName XNAME_DefaultNull = XName.Get(NAME_DefaultNull);
static readonly XName XNAME_AllowNull = XName.Get(NAME_AllowNull);
static readonly XName XNAME_IsGenericWritable = XName.Get(NAME_IsGenericWritable);
static readonly XName XNAME_DisplayNameResource = XName.Get(NAME_DisplayNameResource);
static readonly XName XNAME_DescriptionResource = XName.Get(NAME_DescriptionResource);
static readonly XName XNAME_ResourceType = XName.Get(NAME_ResourceType);
static readonly XName XNAME_TableName = XName.Get(NAME_TableName);
static readonly XName XNAME_ColName = XName.Get(NAME_ColName);
static readonly XName XNAME_Byte = XName.Get(NAME_Byte);
static readonly XName XNAME_SByte = XName.Get(NAME_SByte);
static readonly XName XNAME_ByteArray = XName.Get(NAME_ByteArray);
static readonly XName XNAME_MultiStringValue = XName.Get(NAME_MultiStringValue);
static readonly XName XNAME_MD5Hash = XName.Get(NAME_MD5Hash);
static readonly XName XNAME_ByteValues = XName.Get(NAME_ByteValues);
static readonly XName XNAME_Short = XName.Get(NAME_Short);
static readonly XName XNAME_UShort = XName.Get(NAME_UShort);
static readonly XName XNAME_Int = XName.Get(NAME_Int);
static readonly XName XNAME_UInt = XName.Get(NAME_UInt);
static readonly XName XNAME_Long = XName.Get(NAME_Long);
static readonly XName XNAME_ULong = XName.Get(NAME_ULong);
static readonly XName XNAME_Double = XName.Get(NAME_Double);
static readonly XName XNAME_Float = XName.Get(NAME_Float);
static readonly XName XNAME_Decimal = XName.Get(NAME_Decimal);
static readonly XName XNAME_NVarChar = XName.Get(NAME_NVarChar);
static readonly XName XNAME_Char = XName.Get(NAME_Char);
static readonly XName XNAME_DateTime = XName.Get(NAME_DateTime);
static readonly XName XNAME_TimeSpan = XName.Get(NAME_TimeSpan);
static readonly XName XNAME_Bit = XName.Get(NAME_Bit);
static readonly XName XNAME_Text = XName.Get(NAME_Text);
static readonly XName XNAME_VolumeIdentifier = XName.Get(NAME_VolumeIdentifier);
static readonly XName XNAME_DriveType = XName.Get(NAME_DriveType);
static readonly XName XNAME_MaxLength = XName.Get(NAME_MaxLength);

private static string _templateFolder = null;
private static EnvDTE.DTE _dte = null;
private static EnvDTE.Solution _solution = null;
private static EnvDTE.ProjectItem _templateItem = null;
private static EnvDTE.Project _currentProject = null;
private static ProjectInfoObject _projectInfo = null;
private static string _defaultNamespace = null;
private XDocument _entityDefinitionsDocument;

string TemplateFolder
{
	get
	{
		if (_templateFolder == null)
			_templateFolder = Path.GetDirectoryName(Host.TemplateFile);
		return _templateFolder;
	}
}

string DefaultNamespace
{
	get
	{
		if (_defaultNamespace != null)
			return _defaultNamespace;
		_defaultNamespace = GetCurrentItemPropertyString("CustomToolNamespace");
		if (!String.IsNullOrEmpty(_defaultNamespace))
			return _defaultNamespace;
		try
		{
			_defaultNamespace = System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")?.ToString();
			if (!String.IsNullOrEmpty(_defaultNamespace))
				return _defaultNamespace;
		}
		catch { }
		_defaultNamespace = GetCurrentItemPropertyString("RootNamespace");
		if (String.IsNullOrEmpty(_defaultNamespace))
			_defaultNamespace = (String.IsNullOrEmpty(ProjectInfo.DefaultNamespace)) ? ProjectInfo.RootNamespace ?? "" : ProjectInfo.DefaultNamespace;
		return _defaultNamespace;
	}
}

EnvDTE.DTE DTE
{
	get
	{
		if (_dte == null)
			_dte = (EnvDTE.DTE)((Host as IServiceProvider).GetService(typeof(EnvDTE.DTE)));
		return _dte;
	}
}

EnvDTE.Solution Solution
{
	get
	{
		if (_solution == null)
			_solution = DTE.Solution;
		return _solution;
	}
}

EnvDTE.ProjectItem TemplateItem
{
	get
	{
		if (_templateItem == null)
			_templateItem = Solution.FindProjectItem(Host.TemplateFile);
		return _templateItem;
	}
}

EnvDTE.Project CurrentProject
{
	get
	{
		if (_currentProject == null)
			_currentProject = TemplateItem.ContainingProject;
		return _currentProject;
	}
}

ProjectInfoObject ProjectInfo
{
	get
	{
		if (_projectInfo == null)
			_projectInfo = new ProjectInfoObject(CurrentProject);
		return _projectInfo;
	}
}

string CustomToolOutput { get { return GetCurrentItemPropertyString("CustomToolOutput"); } }

string ActiveConfig { get { return GetPropertyString(Solution.Properties, "ActiveConfig"); } }

XElement FindRootEntityByName(string name)
{
    if (name is null)
        return null;
    XAttribute matchingAttribute = EntityDefinitionsDocument.Root?.Element(XNAME_Root)?.Elements(XNAME_Entity).Attributes(XNAME_Name).FirstOrDefault(a => a.Value == name);
    if (matchingAttribute is null)
        return null;
    return matchingAttribute.Parent;
}

XElement FindRootEnumByName(string name)
{
    if (name is null)
        return null;
    XAttribute matchingAttribute = EntityDefinitionsDocument.Root?.Element(XNAME_Root)?.Elements(XNAME_EnumTypes).Elements().Attributes(XNAME_Name).FirstOrDefault(a => a.Value == name);
    if (matchingAttribute is null)
        return null;
    return matchingAttribute.Parent;
}

XElement FindRootByName(string name) { return (name is null) ? null : (FindRootEntityByName(name) ?? FindRootEnumByName(name)); }

XElement FindLocalEntityByName(string name)
{
    if (name is null)
        return null;
    XAttribute matchingAttribute = EntityDefinitionsDocument.Root?.Element(XNAME_Local)?.Elements(XNAME_Entity).Attributes(XNAME_Name).FirstOrDefault(a => a.Value == name);
    if (matchingAttribute is null)
        return FindRootEntityByName(name);
    return matchingAttribute.Parent;
}

XElement FindLocalEnumByName(string name)
{
    if (name is null)
        return null;
    XAttribute matchingAttribute = EntityDefinitionsDocument.Root?.Element(XNAME_Local)?.Elements(XNAME_EnumTypes).Elements().Attributes(XNAME_Name).FirstOrDefault(a => a.Value == name);
    if (matchingAttribute is null)
        return FindRootEnumByName(name);
    return matchingAttribute.Parent;
}

XElement FindLocalByName(string name) { return (name is null) ? null : (FindLocalEntityByName(name) ?? FindLocalEnumByName(name)); }

XElement FindUpstreamEntityByName(string name)
{
    if (name is null)
        return null;
    XAttribute matchingAttribute = EntityDefinitionsDocument.Root?.Element(XNAME_Upstream)?.Elements(XNAME_Entity).Attributes(XNAME_Name).FirstOrDefault(a => a.Value == name);
    if (matchingAttribute is null)
        return FindRootEntityByName(name);
    return matchingAttribute.Parent;
}

XElement FindUpstreamEnumByName(string name)
{
    if (name is null)
        return null;
    XAttribute matchingAttribute = EntityDefinitionsDocument.Root?.Element(XNAME_Upstream)?.Elements(XNAME_EnumTypes).Elements().Attributes(XNAME_Name).FirstOrDefault(a => a.Value == name);
    if (matchingAttribute is null)
        return FindRootEnumByName(name);
    return matchingAttribute.Parent;
}

XElement FindUpstreamByName(string name) { return (name is null) ? null : (FindUpstreamEntityByName(name) ?? FindUpstreamEnumByName(name)); }

XElement FindRootPropertyByFullName(string fullName)
{
    if (fullName is null)
        return null;
    XAttribute matchingAttribute = EntityDefinitionsDocument.Root.Element(XNAME_Root).Elements(XNAME_Entity).Elements(XNAME_Properties).Elements().Attributes(XNAME_FullName)
        .FirstOrDefault(a => a.Value == fullName);
    if (matchingAttribute is null)
        return null;
    return matchingAttribute.Parent;
}

XElement FindRootFieldByFullName(string fullName)
{
    if (fullName is null)
        return null;
    XAttribute matchingAttribute = EntityDefinitionsDocument.Root.Element(XNAME_Root).Elements(XNAME_EnumTypes).Elements().Elements(XNAME_Field).Attributes(XNAME_FullName)
        .FirstOrDefault(a => a.Value == fullName);
    if (matchingAttribute is null)
        return null;
    return matchingAttribute.Parent;
}

XElement FindRootMemberByFullName(string fullName) { return (fullName is null) ? null : (FindRootPropertyByFullName(fullName) ?? FindRootFieldByFullName(fullName)); }

XElement FindLocalPropertyByFullName(string fullName)
{
    if (fullName is null)
        return null;
    XAttribute matchingAttribute = EntityDefinitionsDocument.Root.Element(XNAME_Local).Elements(XNAME_Entity).Elements(XNAME_Properties).Elements().Attributes(XNAME_FullName)
        .FirstOrDefault(a => a.Value == fullName);
    if (matchingAttribute is null)
        return FindRootPropertyByFullName(fullName);
    return matchingAttribute.Parent;
}

XElement FindLocalFieldByFullName(string fullName)
{
    if (fullName is null)
        return null;
    XAttribute matchingAttribute = EntityDefinitionsDocument.Root.Element(XNAME_Local).Elements(XNAME_EnumTypes).Elements().Elements(XNAME_Field).Attributes(XNAME_FullName)
        .FirstOrDefault(a => a.Value == fullName);
    if (matchingAttribute is null)
        return FindRootFieldByFullName(fullName);
    return matchingAttribute.Parent;
}

XElement FindLocalMemberByFullName(string fullName) { return (fullName is null) ? null : (FindLocalPropertyByFullName(fullName) ?? FindLocalFieldByFullName(fullName)); }

XElement FindUpstreamPropertyByFullName(string fullName)
{
    if (fullName is null)
        return null;
    XAttribute matchingAttribute = EntityDefinitionsDocument.Root.Element(XNAME_Upstream).Elements(XNAME_Entity).Elements(XNAME_Properties).Elements().Attributes(XNAME_FullName)
        .FirstOrDefault(a => a.Value == fullName);
    if (matchingAttribute is null)
        return FindRootPropertyByFullName(fullName);
    return matchingAttribute.Parent;
}

XElement FindUpstreamFieldByFullName(string fullName)
{
    if (fullName is null)
        return null;
    XAttribute matchingAttribute = EntityDefinitionsDocument.Root.Element(XNAME_Upstream).Elements(XNAME_EnumTypes).Elements().Elements(XNAME_Field).Attributes(XNAME_FullName)
        .FirstOrDefault(a => a.Value == fullName);
    if (matchingAttribute is null)
        return FindRootFieldByFullName(fullName);
    return matchingAttribute.Parent;
}

XElement FindUpstreamMemberByFullName(string fullName) { return (fullName is null) ? null : (FindUpstreamPropertyByFullName(fullName) ?? FindUpstreamFieldByFullName(fullName)); }

XElement GetEnumPropertyEnumType(XElement enumPropertyElement)
{
    XElement parent = enumPropertyElement?.Parent;
    if (parent is null || enumPropertyElement.Name != XNAME_Enum)
        return null;
    switch (parent.Name.LocalName)
    {
        case "Root":
            return FindRootEnumByName(enumPropertyElement.Attribute(XNAME_Name)?.Value);
        case "Local":
            return FindLocalEnumByName(enumPropertyElement.Attribute(XNAME_Name)?.Value);
        case "Upstream":
            return FindUpstreamEnumByName(enumPropertyElement.Attribute(XNAME_Name)?.Value);
        default:
            return null;
    }
}

XElement GetEnumPropertyDefaultField(XElement enumPropertyElement)
{
    XElement parent = enumPropertyElement?.Parent;
    if (parent is null || enumPropertyElement.Name != XNAME_Enum)
        return null;
    switch (parent.Name.LocalName)
    {
        case "Root":
            return FindRootFieldByFullName(enumPropertyElement.Element(XNAME_Default)?.Value);
        case "Local":
            return FindLocalFieldByFullName(enumPropertyElement.Element(XNAME_Default)?.Value);
        case "Upstream":
            return FindUpstreamFieldByFullName(enumPropertyElement.Element(XNAME_Default)?.Value);
        default:
            return null;
    }
}

XElement GetEnumFieldAmbientEnumField(XElement enumFieldElement)
{
    XElement parent = enumFieldElement?.Parent;
    if (parent is null || enumFieldElement.Name != XNAME_Enum)
        return null;
    switch (parent.Name.LocalName)
    {
        case "Root":
            return FindRootFieldByFullName(enumFieldElement.Elements(XNAME_AmbientEnum).Attributes(XNAME_Value).Select(a => a.Value).FirstOrDefault());
        case "Local":
            return FindLocalFieldByFullName(enumFieldElement.Elements(XNAME_AmbientEnum).Attributes(XNAME_Value).Select(a => a.Value).FirstOrDefault());
        case "Upstream":
            return FindUpstreamFieldByFullName(enumFieldElement.Elements(XNAME_AmbientEnum).Attributes(XNAME_Value).Select(a => a.Value).FirstOrDefault());
        default:
            return null;
    }
}

XElement GetRelatedEntityReferenceEntity(XElement relatedEntityPropertyElement)
{
    XElement parent = relatedEntityPropertyElement?.Parent;
    if (parent is null || (relatedEntityPropertyElement.Name != XNAME_RelatedEntity && relatedEntityPropertyElement.Name != XNAME_NewRelatedEntity))
        return null;
    switch (parent.Name.LocalName)
    {
        case "Root":
            return FindRootEntityByName(relatedEntityPropertyElement.Attribute(XNAME_Reference)?.Value);
        case "Local":
            return FindLocalEntityByName(relatedEntityPropertyElement.Attribute(XNAME_Reference)?.Value);
        case "Upstream":
            return FindUpstreamEntityByName(relatedEntityPropertyElement.Attribute(XNAME_Reference)?.Value);
        default:
            return null;
    }
}

XElement GetCollectionNavigationItemEntity(XElement collectionNavigationPropertyElement)
{
    XElement parent = collectionNavigationPropertyElement?.Parent;
    if (parent is null || (collectionNavigationPropertyElement.Name != XNAME_CollectionNavigation && collectionNavigationPropertyElement.Name != XNAME_NewCollectionNavigation))
        return null;
    switch (parent.Name.LocalName)
    {
        case "Root":
            return FindRootEntityByName(collectionNavigationPropertyElement.Attribute(XNAME_ItemType)?.Value);
        case "Local":
            return FindLocalEntityByName(collectionNavigationPropertyElement.Attribute(XNAME_ItemType)?.Value);
        case "Upstream":
            return FindUpstreamEntityByName(collectionNavigationPropertyElement.Attribute(XNAME_ItemType)?.Value);
        default:
            return null;
    }
}

IEnumerable<XElement> GetBaseEntities(XElement entityElement)
{
    XElement parent = entityElement?.Parent;
    if (parent is null || entityElement?.Name != XNAME_Entity)
        return Array.Empty<XElement>();

    IEnumerable<string> names = entityElement.Elements().Select(e => (
        IsType: e.Name == XNAME_ExtendsEntity || e.Name == XNAME_ImplementsEntity,
        IsDef: e.Name == XNAME_ExtendsGenericEntity || e.Name == XNAME_ImplementsGenericEntity,
        Element: e
    )).Where(t => t.IsType || t.IsDef).SelectMany(t => t.Element.Attributes(t.IsType ? XNAME_Type : XNAME_TypeDef)).Select(a => a.Value);
    switch (parent.Name.LocalName)
    {
        case "Root":
            return names.Distinct().Select(n => FindRootEntityByName(n)).Where(e => e is not null);
        case "Local":
            return entityElement.Attributes(XNAME_RootInterface).Select(a => a.Value).Concat(names).Distinct()
                .Select(n => FindLocalEntityByName(n)).Where(e => e is not null);
        case "Upstream":
            return entityElement.Attributes(XNAME_RootInterface).Select(a => a.Value).Concat(names).Distinct()
                .Select(n => FindUpstreamEntityByName(n)).Where(e => e is not null);
        default:
            return Array.Empty<XElement>();
    }
}

void GetAllBaseEntities(XElement entityElement, int level, Collection<(XElement Element, int Level)> collection, Func<IEnumerable<string>, IEnumerable<XElement>> getEntities)
{
    IEnumerable<string> names = entityElement.Elements().Select(e => (
        IsType: e.Name == XNAME_ExtendsEntity || e.Name == XNAME_ImplementsEntity,
        IsDef: e.Name == XNAME_ExtendsGenericEntity || e.Name == XNAME_ImplementsGenericEntity,
        Element: e
    )).Where(t => t.IsType || t.IsDef).SelectMany(t => t.Element.Attributes(t.IsType ? XNAME_Type : XNAME_TypeDef)).Select(a => a.Value);
    int nextLevel = level + 1;
    foreach (XElement baseEntity in getEntities(names))
    {
        IEnumerable<(XElement Element, int Level)> items = collection.Where(e => ReferenceEquals(e.Element, baseEntity));
        if (items.Any())
        {
            (XElement Element, int Level) t = items.First();
            if (level < t.Level)
            {
                collection.Remove(t);
                collection.Add(new(baseEntity, level));
            }
        }
        else
        {
            collection.Add(new(baseEntity, level));
            GetAllBaseEntities(baseEntity, nextLevel, collection, getEntities);
        }
    }
}

XElement[] GetAllBaseEntities(XElement entityElement)
{
    XElement parent = entityElement?.Parent;
    if (parent is null || entityElement?.Name != XNAME_Entity)
        return Array.Empty<XElement>();
    Collection<(XElement Element, int Level)> result = new();
    Func<IEnumerable<string>, IEnumerable<XElement>> getEntities;
    switch (parent.Name.LocalName)
    {
        case "Root":
            getEntities = names => names.Distinct().Select(n => FindRootEntityByName(n)).Where(e => e is not null);
            break;
        case "Local":
            getEntities = names => entityElement.Attributes(XNAME_RootInterface).Select(a => a.Value).Concat(names).Distinct()
                .Select(n => FindLocalEntityByName(n)).Where(e => e is not null);
            break;
        case "Upstream":
            getEntities = names => entityElement.Attributes(XNAME_RootInterface).Select(a => a.Value).Concat(names).Distinct()
                .Select(n => FindUpstreamEntityByName(n)).Where(e => e is not null);
            break;
        default:
            return Array.Empty<XElement>();
    }
    GetAllBaseEntities(entityElement, 0, result, getEntities);
    return result.OrderBy(t => t.Level).Select(t => t.Element).ToArray();
}

XElement[] GetAllBaseProperties(XElement propertyElement, XElement[] orderedBaseEntities, out XElement baseProperty, out bool isNew, out bool doNotEmit)
{
    string propertyName = propertyElement?.Attribute(XNAME_Name)?.Value;
    if (propertyName is null || orderedBaseEntities is null || orderedBaseEntities.Length == 0)
    {
        baseProperty = propertyElement;
        isNew = doNotEmit = false;
        return Array.Empty<XElement>();
    }
    XName baseName;
    XName inheritedName;
    switch (propertyElement.Name.LocalName)
    {
        case "NewIdNavRef":
            isNew = false;
            doNotEmit = true;
            baseName = XNAME_UniqueIdentifier;
            inheritedName = XNAME_NewIdNavRef;
            break;
        case "NewRelatedEntity":
            isNew = true;
            doNotEmit = false;
            baseName = XNAME_RelatedEntity;
            inheritedName = XNAME_NewRelatedEntity;
            break;
        case "NewCollectionNavigation":
            isNew = true;
            doNotEmit = false;
            baseName = XNAME_CollectionNavigation;
            inheritedName = XNAME_NewCollectionNavigation;
            break;
        default:
        isNew = doNotEmit = false;
            baseProperty = propertyElement;
            return orderedBaseEntities.Elements(XNAME_Properties).Elements(propertyElement.Name).Attributes(XNAME_Name).Where(a => a.Value == propertyName).Select(a => a.Parent).ToArray();
    }
    IEnumerable<XElement> results = orderedBaseEntities.Elements(XNAME_Properties).Elements().Where(e => e.Name == baseName || e.Name == inheritedName)
        .Attributes(XNAME_Name).Where(a => a.Value == propertyName).Select(a => a.Parent);
    baseProperty = results.Where(e => e.Name == baseName).DefaultIfEmpty(propertyElement).First();
    return results.ToArray();
}

XElement GetRelatedEntityPrimaryKeyProperty(XElement relatedEntityPropertyElement)
{
    XElement parent = relatedEntityPropertyElement?.Parent;
    if (parent is null || (relatedEntityPropertyElement.Name != XNAME_RelatedEntity && relatedEntityPropertyElement.Name != XNAME_NewRelatedEntity))
        return null;
    switch (parent.Name.LocalName)
    {
        case "Root":
            return FindRootPropertyByFullName(relatedEntityPropertyElement.Attribute(XNAME_PrimaryKey)?.Value);
        case "Local":
            return FindLocalPropertyByFullName(relatedEntityPropertyElement.Attribute(XNAME_PrimaryKey)?.Value);
        case "Upstream":
            return FindUpstreamPropertyByFullName(relatedEntityPropertyElement.Attribute(XNAME_PrimaryKey)?.Value);
        default:
            return null;
    }
}

XElement GetCollectionNavigationForeignKeyProperty(XElement collectionNavigationPropertyElement)
{
    XElement parent = collectionNavigationPropertyElement?.Parent;
    if (parent is null || (collectionNavigationPropertyElement.Name != XNAME_CollectionNavigation && collectionNavigationPropertyElement.Name != XNAME_NewCollectionNavigation))
        return null;
    switch (parent.Name.LocalName)
    {
        case "Root":
            return FindRootPropertyByFullName(collectionNavigationPropertyElement.Attribute(XNAME_ForeignKey)?.Value);
        case "Local":
            return FindLocalPropertyByFullName(collectionNavigationPropertyElement.Attribute(XNAME_ForeignKey)?.Value);
        case "Upstream":
            return FindUpstreamPropertyByFullName(collectionNavigationPropertyElement.Attribute(XNAME_ForeignKey)?.Value);
        default:
            return null;
    }
}

IEnumerable<FileInfo> GetProjectItemFiles(EnvDTE.ProjectItem pi)
{
	for (int i = 0; i < pi.FileCount; i++)
		yield return new System.IO.FileInfo(pi.FileNames[(short)(i + 1)]);
}

IEnumerable<FileInfo> GetProjectFiles(Func<EnvDTE.ProjectItem, System.IO.FileInfo, bool> predicate = null)
{
	IEnumerable<EnvDTE.ProjectItem> items = CurrentProject.ProjectItems.OfType<EnvDTE.ProjectItem>().Where(pi => ProjectInfo.FileKind.Equals(new Guid(pi.Kind)));

	if (predicate == null)
		return items.SelectMany(pi => GetProjectItemFiles(pi));

	return items.SelectMany(pi => GetProjectItemFiles(pi).Where(fi => predicate(pi, fi)));
}

IEnumerable<FileInfo> GetCodeProjectFiles() { return GetProjectFiles((EnvDTE.ProjectItem pi, System.IO.FileInfo fi) => pi.FileCodeModel != null); }

IEnumerable<FileInfo> GetNonCodeProjectFiles() { return GetProjectFiles((EnvDTE.ProjectItem pi, System.IO.FileInfo fi) => pi.FileCodeModel == null); }

XText ToWhiteSpaceNormalized(XText source)
{
    string text = source.Value;
    if (NormalizeNewLineRegex.IsMatch(text))
        text = NormalizeNewLineRegex.Replace(text, Environment.NewLine);
    if (TrimOuterBlankLinesRegex.IsMatch(text))
        text = TrimOuterBlankLinesRegex.Replace(text, Environment.NewLine);
    if (NormalizeWsRegex.IsMatch(text))
        text = NormalizeWsRegex.Replace(text, " ");
    return new XText(StripWsRegex.IsMatch(text) ? StripWsRegex.Replace(text, "") : text);
}

XElement WsNormalizedWithoutElementNamespace(XElement sourceParent)
{
    if (sourceParent.Name.LocalName == "langword")
        return new XElement(XNamespace.None.GetName("see"), new XAttribute("langword", sourceParent.Value));
    XElement resultElement = new XElement(XNamespace.None.GetName(sourceParent.Name.LocalName));
    foreach (XAttribute attribute in sourceParent.Attributes())
        resultElement.Add(new XAttribute(attribute));
    XNode sourceNode = sourceParent.Nodes().FirstOrDefault(n => n is XElement || n is XText t && !string.IsNullOrWhiteSpace(t.Value));
    if (sourceNode is null)
        return resultElement;
    if (sourceNode is XText text)
        resultElement.Add(ToWhiteSpaceNormalized(text));
    else
        resultElement.Add(WsNormalizedWithoutElementNamespace((XElement)sourceNode));
    while ((sourceNode = sourceNode.NodesAfterSelf().FirstOrDefault(n => n is XElement || n is XText t && (!string.IsNullOrWhiteSpace(t.Value) || (t.NextNode is not null && t.NextNode is not XText)))) is not null)
    {
        if (sourceNode is XText xText)
            resultElement.Add(ToWhiteSpaceNormalized(xText));
        else
            resultElement.Add(WsNormalizedWithoutElementNamespace((XElement)sourceNode));
    }
    return resultElement;
}

XElement WithoutElementNamespace(XElement sourceParent)
{
    if (sourceParent.Name.LocalName == "langword")
        return new XElement(XNamespace.None.GetName("see"), new XAttribute("langword", sourceParent.Value));
    XElement resultElement = new XElement(XNamespace.None.GetName(sourceParent.Name.LocalName));
    foreach (XAttribute attribute in sourceParent.Attributes())
        resultElement.Add(new XAttribute(attribute));
    XNode sourceNode = sourceParent.Nodes().FirstOrDefault(n => n is XElement || n is XText t && !string.IsNullOrWhiteSpace(t.Value));
    if (sourceNode is null)
        return resultElement;
    if (sourceNode is XText text)
        resultElement.Add(new XText(text));
    else
        resultElement.Add(WithoutElementNamespace((XElement)sourceNode));
    while ((sourceNode = sourceNode.NodesAfterSelf().FirstOrDefault(n => n is XElement || n is XText t && (!string.IsNullOrWhiteSpace(t.Value) || (t.NextNode is not null && t.NextNode is not XText)))) is not null)
    {
        if (sourceNode is XText xText)
            resultElement.Add(new XText(xText));
        else
            resultElement.Add(WithoutElementNamespace((XElement)sourceNode));
    }
    return resultElement;
}

IEnumerable<XElement> GetByNames(XElement source, params XName[] names) => names.SelectMany(n => source.Elements(n));

string[] ToXmlLines(IEnumerable<XElement> elements)
{
    if (elements is null || !elements.Any())
        return Array.Empty<string>();
    using StringWriter stringWriter = new StringWriter();
    XDocument doc = new XDocument(new XElement(WsNormalizedWithoutElementNamespace(elements.First())));
    using (XmlWriter writer = XmlWriter.Create(stringWriter, new XmlWriterSettings() { Indent = true, OmitXmlDeclaration = true }))
    {
        doc.WriteTo(writer);
        writer.Flush();
    }
    foreach (XElement e in elements.Skip(1))
    {
        stringWriter.WriteLine();
        using XmlWriter xmlWriter = XmlWriter.Create(stringWriter, new XmlWriterSettings() { Indent = true, OmitXmlDeclaration = true });
        doc = new XDocument(new XElement(WsNormalizedWithoutElementNamespace(e)));
        doc.WriteTo(xmlWriter);
        xmlWriter.Flush();
    }
    string result = stringWriter.ToString();
    string[] lines = NewLineRegex.IsMatch(result) ? NewLineRegex.Split(result) : new string[] { result };
    int trimLength = lines.Select(t => LeadingWsRegex.Match(t)).Select(m => m.Success ? m.Length : 0).Min();
    return (trimLength > 0) ? lines.Select(t => t.Substring(trimLength)).ToArray() : lines;
}

Type ToUnderlyingType(Type type)
{
    if (type is null)
        return null;
    Type e;
    if (type.HasElementType)
    {
        e = type.GetElementType();
        if (e.IsArray || e.IsPointer)
            return type;
        if (type.IsArray || type.IsPointer)
            return ToUnderlyingType(e).MakeArrayType();
        return ToUnderlyingType(e);
    }

    if (type.IsValueType)
    {
        if (type.IsGenericType && typeof(Nullable<>).IsAssignableFrom(type.GetGenericTypeDefinition()))
            return ToUnderlyingType(Nullable.GetUnderlyingType(type));
        if (type.IsEnum)
            type = Enum.GetUnderlyingType(type);
        if (type.IsPrimitive || type == typeof(decimal) || type == typeof(DateTime) || type == typeof(DateTimeOffset) || type == typeof(TimeSpan) || type == typeof(Guid))
            return type;
    }
    else
    {
        if (type == typeof(string))
            return type;
        if (type == typeof(Uri))
            return typeof(string);
    }
    e = type.GetInterfaces().Where(i => i.IsGenericType && typeof(IEnumerable<>) == i.GetGenericTypeDefinition()).Select(i => i.GetGenericArguments()[0]).FirstOrDefault();
    if (e is not null)
    {
        Type u = ToUnderlyingType(e);
        if (u.IsPrimitive || u == typeof(string) || u == typeof(decimal) || u == typeof(DateTime) || u == typeof(DateTimeOffset) || u == typeof(TimeSpan) || u == typeof(Guid))
            return u.MakeArrayType();
        return e.MakeArrayType();
    }
    return type;
}

string ToSqlTypeName(Type type, out string fullName, out Type dbCompatible)
{
    if (type is null)
    {
        fullName = "NULL";
        dbCompatible = null;
        return fullName;
    }
    dbCompatible = ToUnderlyingType(type);
    if (dbCompatible.IsPrimitive)
    {
        if (dbCompatible == typeof(char))
        {
            fullName = "CHARACTER(1)";
            return "CHARACTER";
        }
        if (dbCompatible == typeof(bool))
            fullName = "BIT";
        else if (dbCompatible == typeof(byte))
            fullName = "UNSIGNED TINYINT";
        else if (dbCompatible == typeof(sbyte))
            fullName = "TINYINT";
        else if (dbCompatible == typeof(short))
            fullName = "SMALLINT";
        else if (dbCompatible == typeof(ushort))
            fullName = "UNSIGNED SMALLINT";
        else if (dbCompatible == typeof(int))
            fullName = "INT";
        else if (dbCompatible == typeof(uint))
            fullName = "UNSIGNED INT";
        else if (dbCompatible == typeof(long))
            fullName = "BIGINT";
        else if (dbCompatible == typeof(ulong))
            fullName = "UNSIGNED BIGINT";
        else
            fullName = "REAL";
    }
    else if (dbCompatible == typeof(decimal))
        fullName = "NUMERIC";
    else if (dbCompatible == typeof(DateTime))
        fullName = "DATETIME";
    else if (dbCompatible == typeof(DateTimeOffset))
        fullName = "DATETIMEOFFSET";
    else if (dbCompatible == typeof(TimeSpan))
        fullName = "TIME";
    else if (dbCompatible == typeof(Guid))
        fullName = "UNIQUEIDENTIFIER";
    else if (dbCompatible == typeof(string))
        fullName = "TEXT";
    else
        fullName = "BLOB";
    return fullName;
}

bool TryGetRange(Type type, out object minValue, out object maxValue)
{
    if (type.HasElementType)
        type = type.GetElementType();
    if (type.IsGenericType && typeof(Nullable<>).IsAssignableFrom(type.GetGenericTypeDefinition()))
        type = ToUnderlyingType(Nullable.GetUnderlyingType(type));
    if (type == typeof(string))
    {
        minValue = maxValue = null;
        return false;
    }
    if (type.IsEnum)
    {
        Array values = Enum.GetValues(type);
        Array.Sort(values);
        minValue = values.GetValue(0);
        if (type.GetCustomAttribute<FlagsAttribute>() is null)
            maxValue = values.GetValue(values.Length - 1);
        else if (type == typeof(byte))
            maxValue = Enum.ToObject(type, values.Cast<byte>().Aggregate((x, y) => (byte)(x | y)));
        else if (type == typeof(sbyte))
            maxValue = Enum.ToObject(type, values.Cast<sbyte>().Aggregate((x, y) => (sbyte)(x | y)));
        else if (type == typeof(short))
            maxValue = Enum.ToObject(type, values.Cast<short>().Aggregate((x, y) => (short)(x | y)));
        else if (type == typeof(ushort))
            maxValue = Enum.ToObject(type, values.Cast<ushort>().Aggregate((x, y) => (ushort)(x | y)));
        else if (type == typeof(int))
            maxValue = Enum.ToObject(type, values.Cast<int>().Aggregate((x, y) => x | y));
        else if (type == typeof(uint))
            maxValue = Enum.ToObject(type, values.Cast<uint>().Aggregate((x, y) => x | y));
        else if (type == typeof(ulong))
            maxValue = Enum.ToObject(type, values.Cast<ulong>().Aggregate((x, y) => x | y));
        else
            maxValue = Enum.ToObject(type, values.Cast<long>().Aggregate((x, y) => x | y));
        return true;
    }
    if (type.IsPrimitive)
    {
        if (type == typeof(byte))
        {
            minValue = byte.MinValue;
            maxValue = byte.MaxValue;
        }
        else if (type == typeof(sbyte))
        {
            minValue = sbyte.MinValue;
            maxValue = sbyte.MaxValue;
        }
        else if (type == typeof(short))
        {
            minValue = short.MinValue;
            maxValue = short.MaxValue;
        }
        else if (type == typeof(ushort))
        {
            minValue = ushort.MinValue;
            maxValue = ushort.MaxValue;
        }
        else if (type == typeof(int))
        {
            minValue = int.MinValue;
            maxValue = int.MaxValue;
        }
        else if (type == typeof(uint))
        {
            minValue = uint.MinValue;
            maxValue = uint.MaxValue;
        }
        else if (type == typeof(long))
        {
            minValue = long.MinValue;
            maxValue = long.MaxValue;
        }
        else if (type == typeof(ulong))
        {
            minValue = ulong.MinValue;
            maxValue = ulong.MaxValue;
        }
        else if (type == typeof(float))
        {
            minValue = float.MinValue;
            maxValue = float.MaxValue;
        }
        else
        {
            minValue = maxValue = null;
            return false;
        }
        return true;
    }

    Type e = type.GetInterfaces().Where(i => i.IsGenericType && typeof(IEnumerable<>) == i.GetGenericTypeDefinition()).Select(i => i.GetGenericArguments()[0]).FirstOrDefault();
    if (e is not null && e.IsValueType)
        return TryGetRange(e, out minValue, out maxValue);
    minValue = maxValue = null;
    return false;
}

List<ValidationEventArgs> ValidationErrors { get; } = new();

XDocument EntityDefinitionsDocument
{
    get
    {
        if (_entityDefinitionsDocument is null)
        {
            XmlReaderSettings readerSettings = new XmlReaderSettings();
            readerSettings.Schemas.Add("", Path.Combine(Path.GetDirectoryName(Solution.FullName), "FsInfoCat\\Resources\\EntityDefinitions.xsd"));
            readerSettings.ValidationType = ValidationType.Schema;
            readerSettings.ValidationEventHandler += XmlValidationEventHandler;
            using XmlReader reader = XmlReader.Create(Path.Combine(Path.GetDirectoryName(Solution.FullName), "FsInfoCat\\Resources\\EntityDefinitions.xml"), readerSettings);
            _entityDefinitionsDocument = XDocument.Load(reader, LoadOptions.PreserveWhitespace);
        }
        return _entityDefinitionsDocument;
    }
}

void XmlValidationEventHandler(object sender, ValidationEventArgs e) { ValidationErrors.Add(e); }

internal static T GetProperty<T>(EnvDTE.Properties properties, string key, T defaultValue = default(T))
{
	try { return (T)(properties.Item(key).Value); }
	catch { return defaultValue; }
}

internal static Version GetPropertyVersion(EnvDTE.Properties properties, string key, Version defaultValue = null)
{
	string s = GetProperty<string>(properties, key);
	Version v;
	if (String.IsNullOrEmpty(s) || !Version.TryParse(s.Trim(), out v))
		return defaultValue;

	if (v.Revision != 0)
		return v;

	if (v.Build == 0)
		return new Version(v.Major, v.Minor);

	return new Version(v.Major, v.Minor, v.Build);
}

internal static Guid? GetPropertyGuid(EnvDTE.Properties properties, string key, Guid? defaultValue = null)
{
	string s = GetProperty<string>(properties, key);
	Guid g;
	if (String.IsNullOrEmpty(s) || !Guid.TryParse(s.Trim(), out g))
		return defaultValue;

	return g;
}

internal static string GetPropertyString(EnvDTE.Properties properties, string key, string defaultValue = null)
{
	string s = GetProperty<string>(properties, key);
	if (defaultValue == null || !String.IsNullOrEmpty(s))
		return s;
	return defaultValue;
}

T GetCurrentItemProperty<T>(string key, T defaultValue = default(T))
{
	return GetProperty<T>(TemplateItem.Properties, key, defaultValue);
}

string GetCurrentItemPropertyString(string key, string defaultValue = null)
{
	return GetPropertyString(TemplateItem.Properties, key, defaultValue);
}

Version GetCurrentItemPropertyVersion(string key, Version defaultValue = null)
{
	return GetPropertyVersion(TemplateItem.Properties, key, defaultValue);
}

Guid? GetCurrentItemPropertyGuid(string key, Guid? defaultValue = null)
{
	return GetPropertyGuid(TemplateItem.Properties, key, defaultValue);
}

class ProjectInfoObject
{
	internal string Title { get { return GetProjectPropertyString("Title", ""); } }
	internal string Product { get { return GetProjectPropertyString("Product", ""); } }
	internal string Name { get { return _project.Name; } }
	internal string Description { get { return GetProjectPropertyString("Description", ""); } }
	internal string Copyright { get { return GetProjectPropertyString("Copyright", ""); } }
	internal string Company { get { return GetProjectPropertyString("Company", ""); } }

	internal string RootNamespace { get { return GetProjectPropertyString("RootNamespace", ""); } }
	internal Version AssemblyVersion { get { return GetProjectPropertyVersion("AssemblyVersion"); } }
	internal string FileName { get { return GetProjectPropertyString("FileName", ""); } }
	internal string ApplicationIcon { get { return GetProjectPropertyString("ApplicationIcon", ""); } }
	internal string OutputFileName { get { return GetProjectPropertyString("OutputFileName", ""); } }
	internal Guid? AssemblyGuid { get { return GetProjectPropertyGuid("AssemblyGuid"); } }
	internal string FullPath { get { return GetProjectPropertyString("FullPath", ""); } }
	internal Version AssemblyFileVersion { get { return GetProjectPropertyVersion("AssemblyFileVersion"); } }
	internal string AssemblyName { get { return GetProjectPropertyString("AssemblyName", ""); } }
	internal string LocalPath { get { return GetProjectPropertyString("LocalPath", ""); } }
	internal string DefaultNamespace { get { return GetProjectPropertyString("DefaultNamespace", ""); } }

	internal string FullName { get { return _project.FullName; } }
	internal string SolutionName { get { return GetProjectPropertyString("SolutionName", ""); } }
	internal string TargetFileName { get { return GetProjectPropertyString("TargetFileName", ""); } }
	internal string TargetFrameworkName { get { return (TargetFrameworkMoniker.Keys[0] != null) ? TargetFrameworkMoniker.Keys[0] : ""; } }
	internal Version TargetFrameworkVersion
	{
		get
		{
			Version v;
			if (!String.IsNullOrEmpty(TargetFrameworkMoniker["Version"]) && Version.TryParse((TargetFrameworkMoniker["Version"].StartsWith("v")) ? TargetFrameworkMoniker["Version"].Substring(1) : TargetFrameworkMoniker["Version"], out v))
				return v;

			return null;
		}
	}
	internal Guid FileKind
	{
		get
		{
			Guid g;
			if (Guid.TryParse(EnvDTE.Constants.vsProjectItemKindPhysicalFile, out g))
				return g;
			throw new Exception(String.Format("\"{0}\" (from EnvDTE.Constants.vsProjectItemKindPhysicalFile) is not a valid Guid.", EnvDTE.Constants.vsProjectItemKindPhysicalFile));
		}
	}
	internal System.Collections.Specialized.NameValueCollection TargetFrameworkMoniker
	{
		get
		{
			if (_targetFrameworkMoniker == null)
			{
				_targetFrameworkMoniker = new System.Collections.Specialized.NameValueCollection();
				System.Text.RegularExpressions.Regex keyValueRegex = new System.Text.RegularExpressions.Regex(@"(^|,)(?<k>[^=,]*)(=(?<v>[^,]*))?");
				string s = GetProjectPropertyString("TargetFrameworkMoniker") ?? "";
				foreach (System.Text.RegularExpressions.Match m in keyValueRegex.Matches(s.Trim()))
				{
					if (m.Groups["v"].Success)
						_targetFrameworkMoniker.Add(m.Groups["k"].Value, m.Groups["v"].Value);
					else
						_targetFrameworkMoniker.Add(m.Groups["k"].Value, null);
				}
			}

			return _targetFrameworkMoniker;
		}
	}
	private EnvDTE.Project _project;
	private System.Collections.Specialized.NameValueCollection _targetFrameworkMoniker = null;

	internal ProjectInfoObject(EnvDTE.Project project)
	{
		_project = project;
	}
	internal T GetProjectProperty<T>(string key, T defaultValue = default(T))
	{
		return GetProperty<T>(_project.Properties, key, defaultValue);
	}
	internal string GetProjectPropertyString(string key, string defaultValue = null)
	{
		return GetPropertyString(_project.Properties, key, defaultValue);
	}
	internal Version GetProjectPropertyVersion(string key, Version defaultValue = null)
	{
		return GetPropertyVersion(_project.Properties, key, defaultValue);
	}
	internal Guid? GetProjectPropertyGuid(string key, Guid? defaultValue = null)
	{
		return GetPropertyGuid(_project.Properties, key, defaultValue);
	}
}

#>
